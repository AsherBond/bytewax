<main class="api__content">
<article class="api__article" id="content">
<header class="api__article-header">
<h1 class="api__article-title">Module <strong>bytewax.connectors.kafka</strong></h1>
</header>
<section class="api__article-intro" id="section-intro">
<p>Connectors for <a href="https://kafka.apache.org">Kafka</a>.</p>
<p>Importing this module requires the
<a href="https://github.com/confluentinc/confluent-kafka-python"><code>confluent-kafka</code></a>
package to be installed.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">&#34;&#34;&#34;Connectors for [Kafka](https://kafka.apache.org).

Importing this module requires the
[`confluent-kafka`](https://github.com/confluentinc/confluent-kafka-python)
package to be installed.

&#34;&#34;&#34;
from typing import Dict, Iterable

from confluent_kafka import (
    OFFSET_BEGINNING,
    Consumer,
    KafkaError,
    Producer,
    TopicPartition,
)
from confluent_kafka.admin import AdminClient

from bytewax.inputs import PartitionedInput, StatefulSource
from bytewax.outputs import DynamicOutput, StatelessSink

__all__ = [
    &#34;KafkaInput&#34;,
    &#34;KafkaOutput&#34;,
]


def _list_parts(client, topics):
    for topic in topics:
        # List topics one-by-one so if auto-create is turned on,
        # we respect that.
        cluster_metadata = client.list_topics(topic)
        topic_metadata = cluster_metadata.topics[topic]
        if topic_metadata.error is not None:
            msg = (
                f&#34;error listing partitions for Kafka topic `{topic!r}`: &#34;
                f&#34;{topic_metadata.error.str()}&#34;
            )
            raise RuntimeError(msg)
        part_idxs = topic_metadata.partitions.keys()
        for i in part_idxs:
            yield f&#34;{i}-{topic}&#34;


class _KafkaSource(StatefulSource):
    def __init__(
        self,
        consumer,
        topic,
        part_idx,
        starting_offset,
        resume_state,
        batch_size,
    ):
        self._offset = starting_offset if resume_state is None else resume_state
        # Assign does not activate consumer grouping.
        consumer.assign([TopicPartition(topic, part_idx, self._offset)])
        self._consumer = consumer
        self._topic = topic
        self._batch_size = batch_size
        self._eof = False

    def next_batch(self):
        if self._eof:
            raise StopIteration()

        msgs = self._consumer.consume(self._batch_size, 0.001)

        batch = []
        last_offset = None
        for msg in msgs:
            if msg.error() is not None:
                if msg.error().code() == KafkaError._PARTITION_EOF:
                    # Set self._eof to True and only raise StopIteration
                    # at the next cycle, so that we can emit messages in
                    # this batch
                    self._eof = True
                    break
                else:
                    # Discard all the messages in this batch too
                    err_msg = (
                        f&#34;error consuming from Kafka topic `{self._topic!r}`: &#34;
                        f&#34;{msg.error()}&#34;
                    )
                    raise RuntimeError(err_msg)
            batch.append((msg.key(), msg.value()))
            last_offset = msg.offset()

        # Resume reading from the next message, not this one.
        if last_offset is not None:
            self._offset = last_offset + 1
        return batch

    def snapshot(self):
        return self._offset

    def close(self):
        self._consumer.close()


class KafkaInput(PartitionedInput):
    &#34;&#34;&#34;Use a set of Kafka topics as an input source.

    Kafka messages are emitted into the dataflow as two-tuples of
    `(key_bytes, value_bytes)`.

    Partitions are the unit of parallelism.

    Can support exactly-once processing.
    &#34;&#34;&#34;

    def __init__(
        self,
        brokers: Iterable[str],
        topics: Iterable[str],
        tail: bool = True,
        starting_offset: int = OFFSET_BEGINNING,
        add_config: Dict[str, str] = None,
        batch_size: int = 1,
    ):
        &#34;&#34;&#34;Init.

        Args:
            brokers:
                List of `host:port` strings of Kafka brokers.
            topics:
                List of topics to consume from.
            tail:
                Whether to wait for new data on this topic when the
                end is initially reached.
            starting_offset:
                Can be either `confluent_kafka.OFFSET_BEGINNING` or
                `confluent_kafka.OFFSET_END`. Defaults to beginning of
                topic.
            add_config:
                Any additional configuration properties. See [the
                `rdkafka`
                documentation](https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md)
                for options.
            batch_size:
                How many messages to consume at most at each poll.
                This is 1 by default, which means messages will be
                consumed one at a time. The default setting is suited
                for lower latency, but negatively affects
                throughput. If you need higher throughput, set this to
                a higher value (eg: 1000)

        &#34;&#34;&#34;
        if isinstance(brokers, str):
            msg = &#34;brokers must be an iterable and not a string&#34;
            raise TypeError(msg)
        self._brokers = brokers
        if isinstance(topics, str):
            msg = &#34;topics must be an iterable and not a string&#34;
            raise TypeError(msg)
        self._topics = topics
        self._tail = tail
        self._starting_offset = starting_offset
        self._add_config = {} if add_config is None else add_config
        self._batch_size = batch_size

    def list_parts(self):
        &#34;&#34;&#34;Each Kafka partition is an input partition.&#34;&#34;&#34;
        config = {
            &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
        }
        config.update(self._add_config)
        client = AdminClient(config)

        return list(_list_parts(client, self._topics))

    def build_part(self, for_part, resume_state):
        &#34;&#34;&#34;See ABC docstring.&#34;&#34;&#34;
        part_idx, topic = for_part.split(&#34;-&#34;, 1)
        part_idx = int(part_idx)
        # TODO: Warn and then return None. This might be an indication
        # of dataflow continuation with a new topic (to enable
        # re-partitioning), which is fine.
        assert topic in self._topics, &#34;Can&#39;t resume from different set of Kafka topics&#34;

        config = {
            # We&#39;ll manage our own &#34;consumer group&#34; via recovery
            # system.
            &#34;group.id&#34;: &#34;BYTEWAX_IGNORED&#34;,
            &#34;enable.auto.commit&#34;: &#34;false&#34;,
            &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
            &#34;enable.partition.eof&#34;: str(not self._tail),
        }
        config.update(self._add_config)
        consumer = Consumer(config)
        return _KafkaSource(
            consumer,
            topic,
            part_idx,
            self._starting_offset,
            resume_state,
            self._batch_size,
        )


class _KafkaSink(StatelessSink):
    def __init__(self, producer, topic):
        self._producer = producer
        self._topic = topic

    def write_batch(self, batch):
        for key, value in batch:
            self._producer.produce(self._topic, value, key)
            self._producer.poll(0)
        self._producer.flush()

    def close(self):
        self._producer.flush()


class KafkaOutput(DynamicOutput):
    &#34;&#34;&#34;Use a single Kafka topic as an output sink.

    Items consumed from the dataflow must look like two-tuples of
    `(key_bytes, value_bytes)`. Default partition routing is used.

    Workers are the unit of parallelism.

    Can support at-least-once processing. Messages from the resume
    epoch will be duplicated right after resume.

    &#34;&#34;&#34;

    def __init__(
        self,
        brokers: Iterable[str],
        topic: str,
        add_config: Dict[str, str] = None,
    ):
        &#34;&#34;&#34;Init.

        Args:
            brokers:
                List of `host:port` strings of Kafka brokers.
            topic:
                Topic to produce to.
            add_config:
                Any additional configuration properties. See [the
                `rdkafka`
                documentation](https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md)
                for options.

        &#34;&#34;&#34;
        self._brokers = brokers
        self._topic = topic
        self._add_config = {} if add_config is None else add_config

    def build(self, worker_index, worker_count):
        &#34;&#34;&#34;See ABC docstring.&#34;&#34;&#34;
        config = {
            &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
        }
        config.update(self._add_config)
        producer = Producer(config)
        return _KafkaSink(producer, self._topic)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="api__article-subtitle" id="header-classes">Classes</h2>
<dl>
<dt id="bytewax.connectors.kafka.KafkaInput"><code class="language-python flex name class">
<span>class <span class="ident">KafkaInput</span></span>
<span>(</span><span>brokers: Iterable[str], topics: Iterable[str], tail: bool = True, starting_offset: int = -2, add_config: Dict[str, str] = None, batch_size: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Use a set of Kafka topics as an input source.</p>
<p>Kafka messages are emitted into the dataflow as two-tuples of
<code>(key_bytes, value_bytes)</code>.</p>
<p>Partitions are the unit of parallelism.</p>
<p>Can support exactly-once processing.</p>
<p>Init.</p>
<h2 id="args">Args</h2>
<p>brokers:
List of <code>host:port</code> strings of Kafka brokers.
topics:
List of topics to consume from.
tail:
Whether to wait for new data on this topic when the
end is initially reached.
starting_offset:
Can be either <code>confluent_kafka.OFFSET_BEGINNING</code> or
<code>confluent_kafka.OFFSET_END</code>. Defaults to beginning of
topic.
add_config:
Any additional configuration properties. See <a href="https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md">the
<code>rdkafka</code>
documentation</a>
for options.
batch_size:
How many messages to consume at most at each poll.
This is 1 by default, which means messages will be
consumed one at a time. The default setting is suited
for lower latency, but negatively affects
throughput. If you need higher throughput, set this to
a higher value (eg: 1000)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">class KafkaInput(PartitionedInput):
    &#34;&#34;&#34;Use a set of Kafka topics as an input source.

    Kafka messages are emitted into the dataflow as two-tuples of
    `(key_bytes, value_bytes)`.

    Partitions are the unit of parallelism.

    Can support exactly-once processing.
    &#34;&#34;&#34;

    def __init__(
        self,
        brokers: Iterable[str],
        topics: Iterable[str],
        tail: bool = True,
        starting_offset: int = OFFSET_BEGINNING,
        add_config: Dict[str, str] = None,
        batch_size: int = 1,
    ):
        &#34;&#34;&#34;Init.

        Args:
            brokers:
                List of `host:port` strings of Kafka brokers.
            topics:
                List of topics to consume from.
            tail:
                Whether to wait for new data on this topic when the
                end is initially reached.
            starting_offset:
                Can be either `confluent_kafka.OFFSET_BEGINNING` or
                `confluent_kafka.OFFSET_END`. Defaults to beginning of
                topic.
            add_config:
                Any additional configuration properties. See [the
                `rdkafka`
                documentation](https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md)
                for options.
            batch_size:
                How many messages to consume at most at each poll.
                This is 1 by default, which means messages will be
                consumed one at a time. The default setting is suited
                for lower latency, but negatively affects
                throughput. If you need higher throughput, set this to
                a higher value (eg: 1000)

        &#34;&#34;&#34;
        if isinstance(brokers, str):
            msg = &#34;brokers must be an iterable and not a string&#34;
            raise TypeError(msg)
        self._brokers = brokers
        if isinstance(topics, str):
            msg = &#34;topics must be an iterable and not a string&#34;
            raise TypeError(msg)
        self._topics = topics
        self._tail = tail
        self._starting_offset = starting_offset
        self._add_config = {} if add_config is None else add_config
        self._batch_size = batch_size

    def list_parts(self):
        &#34;&#34;&#34;Each Kafka partition is an input partition.&#34;&#34;&#34;
        config = {
            &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
        }
        config.update(self._add_config)
        client = AdminClient(config)

        return list(_list_parts(client, self._topics))

    def build_part(self, for_part, resume_state):
        &#34;&#34;&#34;See ABC docstring.&#34;&#34;&#34;
        part_idx, topic = for_part.split(&#34;-&#34;, 1)
        part_idx = int(part_idx)
        # TODO: Warn and then return None. This might be an indication
        # of dataflow continuation with a new topic (to enable
        # re-partitioning), which is fine.
        assert topic in self._topics, &#34;Can&#39;t resume from different set of Kafka topics&#34;

        config = {
            # We&#39;ll manage our own &#34;consumer group&#34; via recovery
            # system.
            &#34;group.id&#34;: &#34;BYTEWAX_IGNORED&#34;,
            &#34;enable.auto.commit&#34;: &#34;false&#34;,
            &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
            &#34;enable.partition.eof&#34;: str(not self._tail),
        }
        config.update(self._add_config)
        consumer = Consumer(config)
        return _KafkaSource(
            consumer,
            topic,
            part_idx,
            self._starting_offset,
            resume_state,
            self._batch_size,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="bytewax.inputs.PartitionedInput" href="/apidocs/bytewax.inputs#bytewax.inputs.PartitionedInput">PartitionedInput</a></li>
<li><a title="bytewax.inputs.Input" href="/apidocs/bytewax.inputs#bytewax.inputs.Input">Input</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bytewax.connectors.kafka.KafkaInput.build_part"><code class="language-python name flex">
<span>def <span class="ident">build_part</span></span>(<span>self, for_part, resume_state)</span>
</code></dt>
<dd>
<div class="desc"><p>See ABC docstring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">def build_part(self, for_part, resume_state):
    &#34;&#34;&#34;See ABC docstring.&#34;&#34;&#34;
    part_idx, topic = for_part.split(&#34;-&#34;, 1)
    part_idx = int(part_idx)
    # TODO: Warn and then return None. This might be an indication
    # of dataflow continuation with a new topic (to enable
    # re-partitioning), which is fine.
    assert topic in self._topics, &#34;Can&#39;t resume from different set of Kafka topics&#34;

    config = {
        # We&#39;ll manage our own &#34;consumer group&#34; via recovery
        # system.
        &#34;group.id&#34;: &#34;BYTEWAX_IGNORED&#34;,
        &#34;enable.auto.commit&#34;: &#34;false&#34;,
        &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
        &#34;enable.partition.eof&#34;: str(not self._tail),
    }
    config.update(self._add_config)
    consumer = Consumer(config)
    return _KafkaSource(
        consumer,
        topic,
        part_idx,
        self._starting_offset,
        resume_state,
        self._batch_size,
    )</code></pre>
</details>
</dd>
<dt id="bytewax.connectors.kafka.KafkaInput.list_parts"><code class="language-python name flex">
<span>def <span class="ident">list_parts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Each Kafka partition is an input partition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">def list_parts(self):
    &#34;&#34;&#34;Each Kafka partition is an input partition.&#34;&#34;&#34;
    config = {
        &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
    }
    config.update(self._add_config)
    client = AdminClient(config)

    return list(_list_parts(client, self._topics))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bytewax.connectors.kafka.KafkaOutput"><code class="language-python flex name class">
<span>class <span class="ident">KafkaOutput</span></span>
<span>(</span><span>brokers: Iterable[str], topic: str, add_config: Dict[str, str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Use a single Kafka topic as an output sink.</p>
<p>Items consumed from the dataflow must look like two-tuples of
<code>(key_bytes, value_bytes)</code>. Default partition routing is used.</p>
<p>Workers are the unit of parallelism.</p>
<p>Can support at-least-once processing. Messages from the resume
epoch will be duplicated right after resume.</p>
<p>Init.</p>
<h2 id="args">Args</h2>
<p>brokers:
List of <code>host:port</code> strings of Kafka brokers.
topic:
Topic to produce to.
add_config:
Any additional configuration properties. See <a href="https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md">the
<code>rdkafka</code>
documentation</a>
for options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">class KafkaOutput(DynamicOutput):
    &#34;&#34;&#34;Use a single Kafka topic as an output sink.

    Items consumed from the dataflow must look like two-tuples of
    `(key_bytes, value_bytes)`. Default partition routing is used.

    Workers are the unit of parallelism.

    Can support at-least-once processing. Messages from the resume
    epoch will be duplicated right after resume.

    &#34;&#34;&#34;

    def __init__(
        self,
        brokers: Iterable[str],
        topic: str,
        add_config: Dict[str, str] = None,
    ):
        &#34;&#34;&#34;Init.

        Args:
            brokers:
                List of `host:port` strings of Kafka brokers.
            topic:
                Topic to produce to.
            add_config:
                Any additional configuration properties. See [the
                `rdkafka`
                documentation](https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md)
                for options.

        &#34;&#34;&#34;
        self._brokers = brokers
        self._topic = topic
        self._add_config = {} if add_config is None else add_config

    def build(self, worker_index, worker_count):
        &#34;&#34;&#34;See ABC docstring.&#34;&#34;&#34;
        config = {
            &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
        }
        config.update(self._add_config)
        producer = Producer(config)
        return _KafkaSink(producer, self._topic)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="bytewax.outputs.DynamicOutput" href="/apidocs/bytewax.outputs#bytewax.outputs.DynamicOutput">DynamicOutput</a></li>
<li><a title="bytewax.outputs.Output" href="/apidocs/bytewax.outputs#bytewax.outputs.Output">Output</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bytewax.connectors.kafka.KafkaOutput.build"><code class="language-python name flex">
<span>def <span class="ident">build</span></span>(<span>self, worker_index, worker_count)</span>
</code></dt>
<dd>
<div class="desc"><p>See ABC docstring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">def build(self, worker_index, worker_count):
    &#34;&#34;&#34;See ABC docstring.&#34;&#34;&#34;
    config = {
        &#34;bootstrap.servers&#34;: &#34;,&#34;.join(self._brokers),
    }
    config.update(self._add_config)
    producer = Producer(config)
    return _KafkaSink(producer, self._topic)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
<footer class="api__footer" id="footer">
<p class="api__footer-copyright">
Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.
</p>
</footer>
</article>
<nav class="api__sidebar" id="sidebar">
<ul class="api__sidebar-nav" id="index">
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title">Super-module</h3>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item">
<a title="bytewax.connectors" href="/apidocs/bytewax.connectors/index">bytewax.connectors</a>
</li>
</ul>
</li>
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title"><a href="#header-classes">Classes</a></h3>
<ul class="api__sidebar-nav-classes">
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.connectors.kafka.KafkaInput" href="/apidocs/bytewax.connectors/kafka#bytewax.connectors.kafka.KafkaInput">KafkaInput</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.connectors.kafka.KafkaInput.build_part" href="/apidocs/bytewax.connectors/kafka#bytewax.connectors.kafka.KafkaInput.build_part">build_part</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.connectors.kafka.KafkaInput.list_parts" href="/apidocs/bytewax.connectors/kafka#bytewax.connectors.kafka.KafkaInput.list_parts">list_parts</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.connectors.kafka.KafkaOutput" href="/apidocs/bytewax.connectors/kafka#bytewax.connectors.kafka.KafkaOutput">KafkaOutput</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.connectors.kafka.KafkaOutput.build" href="/apidocs/bytewax.connectors/kafka#bytewax.connectors.kafka.KafkaOutput.build">build</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
