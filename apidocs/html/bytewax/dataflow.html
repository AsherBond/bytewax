<main class="api__content">
<article class="api__article" id="content">
<header class="api__article-header">
<h1 class="api__article-title">Module <strong>bytewax.dataflow</strong></h1>
</header>
<section class="api__article-intro" id="section-intro">
<p>Data model for dataflows and custom operators.</p>
<p>See <code><a title="bytewax.operators" href="/apidocs/bytewax.operators/index">bytewax.operators</a></code> for the built-in operators.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">&#34;&#34;&#34;Data model for dataflows and custom operators.

See `bytewax.operators` for the built-in operators.

&#34;&#34;&#34;
import dataclasses
import functools
import inspect
import itertools
import typing
from dataclasses import dataclass, field
from inspect import Parameter, Signature
from types import FunctionType
from typing import (
    Any,
    Callable,
    ClassVar,
    Dict,
    Generic,
    Iterable,
    List,
    Optional,
    Protocol,
    Type,
    TypeVar,
    overload,
    runtime_checkable,
)

from typing_extensions import Concatenate, ParamSpec, Self

P = ParamSpec(&#34;P&#34;)
R = TypeVar(&#34;R&#34;)
K = TypeVar(&#34;K&#34;)
X_co = TypeVar(&#34;X_co&#34;, covariant=True)


def f_repr(f: Callable) -&gt; str:
    &#34;&#34;&#34;Nicer `repr` for functions with the defining module and line.

    Use this to help with writing easier to debug exceptions in your
    operators.

    The built in repr just shows a memory address.

    &gt;&gt;&gt; def my_f(x):
    ...     pass
    &gt;&gt;&gt; f_repr(my_f)
    &#34;&lt;function &#39;bytewax.dataflow.my_f&#39; line 1&gt;&#34;

    &#34;&#34;&#34;
    if isinstance(f, FunctionType):
        path = f&#34;{f.__module__}.{f.__qualname__}&#34;
        line = f&#34;{f.__code__.co_firstlineno}&#34;
        return f&#34;&lt;function {path!r} line {line}&gt;&#34;
    else:
        return repr(f)


@runtime_checkable
class Port(Protocol):
    &#34;&#34;&#34;Generic interface to a port.

    Either `SinglePort` or `MultiPort`.

    &#34;&#34;&#34;

    port_id: str
    stream_ids: Dict[str, str]


@dataclass(frozen=True)
class SinglePort:
    &#34;&#34;&#34;A input or output location on an `Operator`.

    You won&#39;t be instantiating this manually. The `operator` decorator
    will create these for you whenever an operator function takes or
    returns a `Stream`.

    &#34;&#34;&#34;

    port_id: str
    stream_id: str

    @property
    def stream_ids(self) -&gt; Dict[str, str]:
        &#34;&#34;&#34;Allow this to conform to the `Port` protocol.&#34;&#34;&#34;
        return {&#34;stream&#34;: self.stream_id}


@dataclass(frozen=True)
class MultiPort(Generic[K]):
    &#34;&#34;&#34;A multi-stream input or output location on an `Operator`.

    You won&#39;t be instantiating this manually. The `operator` decorator
    will create these for you whenever an operator function takes or
    returns a `*args` of `Stream` or `**kwargs` of `Stream`s or a
    `MultiStream`.

    &#34;&#34;&#34;

    port_id: str
    stream_ids: Dict[K, str]


@dataclass(frozen=True)
class Operator:
    &#34;&#34;&#34;Base class for an operator type.

    Subclasses of this must be generated via the `operator` builder
    function decorator. See the `bytewax.dataflow` module docstring
    for a tutorial.

    Subclasses will contain the specific configuration fields each
    operator needs.

    &#34;&#34;&#34;

    step_name: str
    step_id: str
    substeps: List[Self]
    ups_names: ClassVar[List[str]]
    dwn_names: ClassVar[List[str]]


@dataclass(frozen=True)
class _CoreOperator(Operator):
    #: This operator is a core operator.
    core: ClassVar[bool] = True


@dataclass(frozen=True)
class _Scope:
    # This will be the ID of the `Dataflow` or `Operator` to modify.
    parent_id: str
    substeps: List[Operator] = field(compare=False, repr=False)
    flow: &#34;Dataflow&#34; = field(compare=False, repr=False)


@runtime_checkable
class _HasScope(Protocol):
    def _get_scopes(self) -&gt; Iterable[_Scope]:
        ...

    def _with_scope(self, scope: _Scope) -&gt; Self:
        ...


@runtime_checkable
class _ToRef(Protocol):
    def _to_ref(self, port_id: str):
        ...


@dataclass(frozen=True)
class DataflowId:
    &#34;&#34;&#34;Unique ID of a dataflow.&#34;&#34;&#34;

    flow_id: str


@dataclass(frozen=True)
class Dataflow:
    &#34;&#34;&#34;Dataflow definition.

    Once you instantiate this, Use the `bytewax.operators` (e.g.
    `bytewax.operators.input`) to create `Stream`s.

    &#34;&#34;&#34;

    flow_id: str
    substeps: List[Operator] = field(default_factory=list)
    _scope: _Scope = field(default=None, compare=False)  # type: ignore[assignment]

    def __post_init__(self):
        if &#34;.&#34; in self.flow_id:
            msg = &#34;flow ID can&#39;t contain a period `.`&#34;
            raise ValueError(msg)
        if self._scope is None:
            # The default context at the `Dataflow` level is recursive and
            # means add things to this object.
            scope = _Scope(self.flow_id, self.substeps, self)
            # Trixy get around the fact this is frozen. We don&#39;t modify
            # after init, though.
            object.__setattr__(self, &#34;_scope&#34;, scope)

    def _get_scopes(self) -&gt; Iterable[_Scope]:
        return [self._scope]

    def _with_scope(self, scope: _Scope) -&gt; Self:
        return dataclasses.replace(self, _scope=scope)

    def _to_ref(self, _port_id: str) -&gt; DataflowId:
        return DataflowId(self.flow_id)


@dataclass(frozen=True)
class Stream(Generic[X_co]):
    &#34;&#34;&#34;Handle to a specific stream of items you can add steps to.

    You won&#39;t be instantiating this manually. Use the
    `bytewax.operators` (e.g. `bytewax.operators.map`,
    `bytewax.operators.filter`, `bytewax.operators.key_on`) to create
    `Stream`s.

    You can reference this stream multiple times to duplicate the data
    within.

    Operator functions take or return this if they want to create an
    input or output port.

    &#34;&#34;&#34;

    stream_id: str
    _scope: _Scope = field(compare=False)

    def flow(self) -&gt; Dataflow:
        &#34;&#34;&#34;The containing `Dataflow`.

        You might want access to this to add &#34;top level&#34; operators
        like `bytewax.operators.merge_all.merge_all`.

        &#34;&#34;&#34;
        return self._scope.flow

    def _get_scopes(self) -&gt; Iterable[_Scope]:
        return [self._scope]

    def _with_scope(self, scope: _Scope) -&gt; Self:
        return dataclasses.replace(self, _scope=scope)

    def _to_ref(self, ref_id: str) -&gt; SinglePort:
        return SinglePort(ref_id, self.stream_id)

    def then(
        self,
        op_fn: Callable[Concatenate[str, Self, P], R],
        step_id: str,
        *args: P.args,
        **kwargs: P.kwargs,
    ) -&gt; R:
        &#34;&#34;&#34;Chain a new step onto this stream.

        This allows you to add intermediate steps to a dataflow
        without needing to nest operator function calls or make
        intermediate variables.

        The following two dataflow definitions are equivalent:

        &gt;&gt;&gt; import bytewax.operators as op
        &gt;&gt;&gt; from bytewax.testing import run_main, TestingSource
        &gt;&gt;&gt; from bytewax.dataflow import Dataflow
        &gt;&gt;&gt; def add_one(item):
        ...     return item + 1

        &gt;&gt;&gt; flow = Dataflow(&#34;map_eg&#34;)
        &gt;&gt;&gt; s = op.input(&#34;inp&#34;, flow, TestingSource(range(3)))
        &gt;&gt;&gt; s = op.map(&#34;add_one&#34;, s, add_one)

        and

        &gt;&gt;&gt; flow = Dataflow(&#34;map_eg&#34;)
        &gt;&gt;&gt; s = op.input(&#34;inp&#34;, flow, TestingSource(range(3))).then(
        ...     op.map, &#34;add_one&#34;, add_one
        ... )

        This kind of method chaining is called a &#34;fluent style API&#34;.

        Because this style requires a single upstream before the `.`,
        this transformation only works for operators that could be
        called like `op_fn(step_id, upstream, ...)`, like
        `bytewax.operators.map`. It will not work for operators like
        `bytewax.operators.join_named`, since they do not have that
        shape of function signature.

        Args:
            step_id: Unique ID.

            op_fn: Operator function. This fluent transformation only
              works on operators that take a single stream as the
              second argument.

            *args: Remaining arguments to pass to `op_fn`.

            **kwargs: Remaining arguments to pass to `op_fn`.

        &#34;&#34;&#34;
        return op_fn(step_id, self, *args, **kwargs)


@dataclass(frozen=True)
class _MultiStream(Generic[K]):
    &#34;&#34;&#34;A bundle of named `Stream`s.

    This is also created internally whenever a builder function takes
    or returns a `*args` of `Stream` or `**kwargs` of `Stream`s.

    &#34;&#34;&#34;

    streams: Dict[K, Stream[Any]]

    def _get_scopes(self) -&gt; Iterable[_Scope]:
        return (stream._scope for stream in self.streams.values())

    def _with_scope(self, scope: _Scope) -&gt; Self:
        streams = {
            name: stream._with_scope(scope) for name, stream in self.streams.items()
        }
        return dataclasses.replace(self, streams=streams)

    def _to_ref(self, port_id: str) -&gt; MultiPort[K]:
        return MultiPort(
            port_id,
            {name: stream.stream_id for name, stream in self.streams.items()},
        )


_OPERATOR_BASE_NAMES = frozenset(typing.get_type_hints(_CoreOperator).keys())


def _anno_to_typ(anno: Any) -&gt; Optional[Type]:
    if anno is Any:
        return object

    if inspect.isclass(anno):
        return anno

    orig = typing.get_origin(anno)
    if orig is not None and inspect.isclass(orig):
        return orig

    return None


def _gen_inp_fields(sig: Signature, sig_annos: Dict[str, Any]) -&gt; Dict[str, Any]:
    inp_fields: Dict[str, Any] = {}
    for name, param in sig.parameters.items():
        # If the argument is un-annotated, assume the type class for
        # &#34;Any&#34;.
        anno = sig_annos.get(name, Any)
        # Assume we pass through the annotation unmodified.
        inp_fields[name] = anno

        typ = _anno_to_typ(anno)
        if typ is not None:
            # If any of the arguments require special casing when
            # they&#39;re *args or **kwargs, find out what the &#34;packed&#34;
            # version of the argument type is. The most common use of
            # this is `*ups: Stream` will actually be stored as a
            # single `_MultiStream`, rather than a `Tuple[Stream]`.
            if issubclass(typ, Stream):
                # If the stream is typed, get that inner type to apply to
                # the `_MultiStream`.
                try:
                    stream_typ_arg = typing.get_args(anno)[0]
                except IndexError:
                    # If not, it&#39;s effectively typed `Any`.
                    stream_typ_arg = Any

                if param.kind == Parameter.VAR_POSITIONAL:
                    inp_fields[name] = _MultiStream[stream_typ_arg]
                elif param.kind == Parameter.VAR_KEYWORD:
                    inp_fields[name] = _MultiStream[stream_typ_arg]

    return inp_fields


def _gen_out_fields(_sig: Signature, sig_annos: Dict[str, Any]) -&gt; Dict[str, Any]:
    out_fields: Dict[str, Any] = {}
    anno = sig_annos.get(&#34;return&#34;, Any)
    typ = _anno_to_typ(anno)
    if typ is not None:
        # A single `Stream` is stored by convention in a field named
        # &#34;down&#34;. This must be first even though it is the same
        # behavior as the else branch because `Stream` is defined
        # using dataclasses and we don&#39;t want to split the stream into
        # it&#39;s private fields.
        if issubclass(typ, Stream) or issubclass(typ, _MultiStream):
            out_fields[&#34;down&#34;] = anno
        # A `None` return value doesn&#39;t store any field.
        elif issubclass(typ, type(None)):
            pass
        # Dataclass is the &#34;named return value&#34; options. We copy all the
        # first level fields into the operator dataclass. We use
        # dataclasses because the stdlib gives us tools to introspect them
        # easily.
        elif dataclasses.is_dataclass(typ):
            out_field_annos = typing.get_type_hints(typ)
            for fld in dataclasses.fields(typ):
                out_fields[fld.name] = out_field_annos.get(fld.name, Any)
        else:
            # If this isn&#39;t a 0 return value function (via `None`) or
            # an N return value function (via a dataclass), there&#39;s a
            # single field called `down`. Copy the annotation.
            out_fields[&#34;down&#34;] = anno
    else:
        # If the return type is not checkable, assume it&#39;s a single
        # value and copy the annotation.
        out_fields[&#34;down&#34;] = anno

    return out_fields


def _gen_op_cls(
    builder: FunctionType,
    sig: Signature,
    sig_annos: Dict[str, Any],
    core: bool,
) -&gt; Type[Operator]:
    if &#34;step_id&#34; not in sig.parameters:
        msg = &#34;builder function requires a &#39;step_id&#39; parameter&#34;
        raise TypeError(msg)

    # First add fields for all the input arguments.
    inp_fields = _gen_inp_fields(sig, sig_annos)
    # Then add fields for the return values.
    out_fields = _gen_out_fields(sig, sig_annos)

    conflicting_fields = frozenset(inp_fields.keys()) &amp; frozenset(out_fields.keys())
    if len(conflicting_fields) &gt; 0:
        fmt_fields = &#34;, &#34;.join(repr(name) for name in conflicting_fields)
        msg = (
            f&#34;{fmt_fields} are both a build function parameter &#34;
            &#34;and a return dataclass field name; rename so there are no &#34;
            &#34;overlapping field names&#34;
        )
        raise TypeError(msg)

    cls_fields: Dict[str, Any] = {}
    cls_fields.update(inp_fields)
    cls_fields.update(out_fields)

    # Now update the types to any that store references instead. This
    # is because some types (like `Stream`) have `_Scope` which would
    # result in circular references (because they contain pointers to
    # the substep list) if stored directly. Their &#34;reference versions&#34;
    # (for `Stream` it&#39;s `SinglePort`) don&#39;t include the scope or
    # anything that is just there to facilitate the fluent API.
    for name, anno in cls_fields.items():
        typ = _anno_to_typ(anno)
        if typ is not None and issubclass(typ, _ToRef):
            method_typs = typing.get_type_hints(typ._to_ref)
            cls_fields[name] = method_typs.get(&#34;return&#34;, Any)

    # Store the names of the upstream and downstream ports to enable
    # visualization.
    ups_names = []
    dwn_names = []
    for name, anno in cls_fields.items():
        typ = _anno_to_typ(anno)
        if typ is not None and (
            issubclass(typ, SinglePort) or issubclass(typ, MultiPort)
        ):
            if name in inp_fields:
                ups_names.append(name)
            elif name in out_fields:
                dwn_names.append(name)

    # `step_id` is defined on the parent class.
    del cls_fields[&#34;step_id&#34;]

    # Because we&#39;re cramming all the input arguments and return value
    # dataclass field names onto the same operator data model
    # dataclass, ensure we aren&#39;t clobbering any of the base class
    # names.
    forbidden_fields = frozenset(cls_fields.keys()) &amp; _OPERATOR_BASE_NAMES
    if len(forbidden_fields) &gt; 0:
        fmt_fields = &#34;, &#34;.join(repr(name) for name in forbidden_fields)
        msg = (
            &#34;builder function can&#39;t have parameters or return dataclass fields &#34;
            &#34;that shadow any of the field names in `bytewax.dataflow.Operator`; &#34;
            f&#34;rename the {fmt_fields} parameter or fields&#34;
        )
        raise TypeError(msg)

    cls_doc = f&#34;&#34;&#34;`{builder.__name__}` operator data model.&#34;&#34;&#34;

    cls_ns = {
        &#34;__doc__&#34;: cls_doc,
        &#34;ups_names&#34;: ups_names,
        &#34;dwn_names&#34;: dwn_names,
    }

    # Now finally build the dataclass definition. This does not
    # actually instantiate it, we do that in the wrapper method.
    cls = dataclasses.make_dataclass(
        builder.__name__,
        cls_fields.items(),
        bases=(_CoreOperator if core else Operator,),
        frozen=True,
        namespace=cls_ns,
    )
    cls.__module__ = builder.__module__

    return cls


def _gen_op_fn(
    sig: Signature,
    sig_annos: Dict[str, Any],
    builder: FunctionType,
    cls: Type[Operator],
    _core: bool,
) -&gt; Callable:
    # Wraps ensures that docstrings and type annotations are the same.
    @functools.wraps(builder)
    def fn(*args, **kwargs):
        try:
            bound = sig.bind(*args, **kwargs)
        except TypeError as ex:
            msg = f&#34;operator {cls.__name__!r} called incorrectly; see cause above&#34;
            raise TypeError(msg) from ex
        bound.apply_defaults()

        for name in cls.ups_names:
            param = sig.parameters[name]
            if param.kind == Parameter.VAR_POSITIONAL:
                vals = bound.arguments[name]
                desc = f&#34;{name!r} *args all&#34;
            elif param.kind == Parameter.VAR_KEYWORD:
                vals = bound.arguments[name].values()
                desc = f&#34;{name!r} **kwargs all&#34;
            else:
                vals = [bound.arguments[name]]
                desc = f&#34;{name!r} argument&#34;

            for val in vals:
                if not isinstance(val, Stream):
                    msg = (
                        f&#34;{desc} must be a `Stream`; &#34;
                        f&#34;got a {type(val)!r} instead; &#34;
                        &#34;did you forget to unpack the result of an operator &#34;
                        &#34;that returns multiple streams?&#34;
                    )
                    raise TypeError(msg)

        step_id = bound.arguments[&#34;step_id&#34;]
        if not isinstance(step_id, str):
            msg = &#34;&#39;step_id&#39; must be a `str`&#34;
            raise TypeError(msg)
        if &#34;.&#34; in step_id:
            msg = &#34;&#39;step_id&#39; can&#39;t contain any periods &#39;.&#39;&#34;
            raise ValueError(msg)

        # Pack `Stream`s of *args and **kwargs into the special type
        # we can re-scope.
        for name, param in sig.parameters.items():
            val = bound.arguments[name]
            anno = sig_annos.get(name, Any)
            typ = _anno_to_typ(anno)
            if typ is not None and issubclass(typ, Stream):
                if param.kind == Parameter.VAR_POSITIONAL:
                    bound.arguments[name] = _MultiStream(dict(enumerate(val)))
                elif param.kind == Parameter.VAR_KEYWORD:
                    bound.arguments[name] = _MultiStream(val)

        outer_scopes = frozenset(
            itertools.chain.from_iterable(
                val._get_scopes()
                for val in bound.arguments.values()
                if isinstance(val, _HasScope)
            )
        )
        if len(outer_scopes) != 1:
            msg = (
                &#34;inconsistent stream scoping; &#34;
                f&#34;found multiple scopes {outer_scopes!r}; &#34;
                &#34;expected one; &#34;
                &#34;possible invalid operator definition; &#34;
                &#34;might be nested `Stream` in arguments to this operator &#34;
                &#34;or return value from previous operator; &#34;
                &#34;see `bytewax.dataflow.operator` docstring for custom &#34;
                &#34;operator rules&#34;
            )
            raise AssertionError(msg)
        # Get the singular outer_scope.
        outer_scope = next(iter(outer_scopes))
        # Re-scope input arguments that have a scope so internal calls
        # to operator methods will result in sub-steps.
        fq_inner_scope_id = f&#34;{outer_scope.parent_id}.{step_id}&#34;
        inner_scope = _Scope(fq_inner_scope_id, [], outer_scope.flow)
        inner_scope = dataclasses.replace(
            inner_scope, flow=inner_scope.flow._with_scope(inner_scope)
        )
        for name, val in bound.arguments.items():
            if isinstance(val, _HasScope):
                bound.arguments[name] = val._with_scope(inner_scope)
        # Creating the nested scope is what defines the new inner
        # fully-qualified step id. We pass this into the builder
        # function in case you need it for error messages.
        bound.arguments[&#34;step_id&#34;] = inner_scope.parent_id

        # Save the input arguments.
        cls_vals = dict(bound.arguments.items())
        cls_vals[&#34;step_name&#34;] = step_id

        # Now unpack the special *args and **kwargs types for calling.
        for name, param in sig.parameters.items():
            val = bound.arguments[name]
            anno = sig_annos.get(name, Any)
            typ = _anno_to_typ(anno)
            if typ is not None and issubclass(typ, Stream):
                if param.kind == Parameter.VAR_POSITIONAL:
                    bound.arguments[name] = tuple(val.streams.values())
                elif param.kind == Parameter.VAR_KEYWORD:
                    bound.arguments[name] = dict(val.streams)

        # Now call the builder to cause sub-steps to be built.
        out = builder(*bound.args, **bound.kwargs)

        # Now unwrap output values into the cls.
        if isinstance(out, Stream) or isinstance(out, _MultiStream):
            cls_vals[&#34;down&#34;] = out
        elif isinstance(out, type(None)):
            pass
        elif dataclasses.is_dataclass(out):
            for fld in dataclasses.fields(out):
                cls_vals[fld.name] = getattr(out, fld.name)
        else:
            cls_vals[&#34;down&#34;] = out

        # Turn into references.
        for name, val in cls_vals.items():
            if isinstance(val, _ToRef):
                fq_ref_id = f&#34;{inner_scope.parent_id}.{name}&#34;
                cls_vals[name] = val._to_ref(fq_ref_id)

        # Now actually build the step instance.
        step = cls(
            substeps=inner_scope.substeps,
            **cls_vals,
        )

        # Check for ID clashes since this will cause streams to be
        # lost.
        existing_step_ids = frozenset(
            existing_step.step_id for existing_step in outer_scope.substeps
        )
        if step.step_id in existing_step_ids:
            msg = (
                f&#34;step {step.step_id!r} already exists; &#34;
                &#34;do you have two steps with the same ID?&#34;
            )
            raise ValueError(msg)

        # And store it in the outer scope.
        outer_scope.substeps.append(step)

        # Re-scope outputs that have a scope so calls to operator
        # methods will not still be added in this operator a substeps.
        if isinstance(out, _HasScope):
            out = out._with_scope(outer_scope)
        elif dataclasses.is_dataclass(out):
            vals = {}
            for fld in dataclasses.fields(out):
                val = getattr(out, fld.name)
                if isinstance(val, _HasScope):
                    vals[fld.name] = val._with_scope(outer_scope)
            out = dataclasses.replace(out, **vals)

        return out

    return fn


F = TypeVar(&#34;F&#34;, bound=Callable[..., Any])


@overload
def operator(builder: F) -&gt; F:
    ...


@overload
def operator(*, _core: bool = False) -&gt; Callable[[F], F]:
    ...


def operator(builder=None, *, _core: bool = False) -&gt; Callable:
    &#34;&#34;&#34;Function decorator to define a new operator.

    See `bytewax.dataflow` module docstring for how to use this.

    &#34;&#34;&#34;

    def inner_deco(builder: FunctionType) -&gt; Callable:
        sig = inspect.signature(builder)
        sig_annos = typing.get_type_hints(builder)
        cls = _gen_op_cls(builder, sig, sig_annos, _core)
        fn = _gen_op_fn(sig, sig_annos, builder, cls, _core)
        fn._op_cls = cls  # type: ignore[attr-defined]
        return fn

    if builder is not None:
        return inner_deco(builder)
    else:
        return inner_deco</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="api__article-subtitle" id="header-functions">Functions</h2>
<dl>
<dt id="bytewax.dataflow.f_repr"><code class="language-python name flex">
<span>def <span class="ident">f_repr</span></span>(<span>f: Callable) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Nicer <code>repr</code> for functions with the defining module and line.</p>
<p>Use this to help with writing easier to debug exceptions in your
operators.</p>
<p>The built in repr just shows a memory address.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def my_f(x):
...     pass
&gt;&gt;&gt; f_repr(my_f)
&quot;&lt;function 'bytewax.dataflow.my_f' line 1&gt;&quot;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">def f_repr(f: Callable) -&gt; str:
    &#34;&#34;&#34;Nicer `repr` for functions with the defining module and line.

    Use this to help with writing easier to debug exceptions in your
    operators.

    The built in repr just shows a memory address.

    &gt;&gt;&gt; def my_f(x):
    ...     pass
    &gt;&gt;&gt; f_repr(my_f)
    &#34;&lt;function &#39;bytewax.dataflow.my_f&#39; line 1&gt;&#34;

    &#34;&#34;&#34;
    if isinstance(f, FunctionType):
        path = f&#34;{f.__module__}.{f.__qualname__}&#34;
        line = f&#34;{f.__code__.co_firstlineno}&#34;
        return f&#34;&lt;function {path!r} line {line}&gt;&#34;
    else:
        return repr(f)</code></pre>
</details>
</dd>
<dt id="bytewax.dataflow.operator"><code class="language-python name flex">
<span>def <span class="ident">operator</span></span>(<span>builder=None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Function decorator to define a new operator.</p>
<p>See <code><a title="bytewax.dataflow" href="/apidocs/bytewax.dataflow">bytewax.dataflow</a></code> module docstring for how to use this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">def operator(builder=None, *, _core: bool = False) -&gt; Callable:
    &#34;&#34;&#34;Function decorator to define a new operator.

    See `bytewax.dataflow` module docstring for how to use this.

    &#34;&#34;&#34;

    def inner_deco(builder: FunctionType) -&gt; Callable:
        sig = inspect.signature(builder)
        sig_annos = typing.get_type_hints(builder)
        cls = _gen_op_cls(builder, sig, sig_annos, _core)
        fn = _gen_op_fn(sig, sig_annos, builder, cls, _core)
        fn._op_cls = cls  # type: ignore[attr-defined]
        return fn

    if builder is not None:
        return inner_deco(builder)
    else:
        return inner_deco</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="api__article-subtitle" id="header-classes">Classes</h2>
<dl>
<dt id="bytewax.dataflow.Dataflow"><code class="language-python flex name class">
<span>class <span class="ident">Dataflow</span></span>
<span>(</span><span>flow_id: str, substeps: List[<a title="bytewax.dataflow.Operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator">Operator</a>] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Dataflow definition.</p>
<p>Once you instantiate this, Use the <code><a title="bytewax.operators" href="/apidocs/bytewax.operators/index">bytewax.operators</a></code> (e.g.
<code><a title="bytewax.operators.input" href="/apidocs/bytewax.operators/index#bytewax.operators.input">input()</a></code>) to create <code><a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a></code>s.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@dataclass(frozen=True)
class Dataflow:
    &#34;&#34;&#34;Dataflow definition.

    Once you instantiate this, Use the `bytewax.operators` (e.g.
    `bytewax.operators.input`) to create `Stream`s.

    &#34;&#34;&#34;

    flow_id: str
    substeps: List[Operator] = field(default_factory=list)
    _scope: _Scope = field(default=None, compare=False)  # type: ignore[assignment]

    def __post_init__(self):
        if &#34;.&#34; in self.flow_id:
            msg = &#34;flow ID can&#39;t contain a period `.`&#34;
            raise ValueError(msg)
        if self._scope is None:
            # The default context at the `Dataflow` level is recursive and
            # means add things to this object.
            scope = _Scope(self.flow_id, self.substeps, self)
            # Trixy get around the fact this is frozen. We don&#39;t modify
            # after init, though.
            object.__setattr__(self, &#34;_scope&#34;, scope)

    def _get_scopes(self) -&gt; Iterable[_Scope]:
        return [self._scope]

    def _with_scope(self, scope: _Scope) -&gt; Self:
        return dataclasses.replace(self, _scope=scope)

    def _to_ref(self, _port_id: str) -&gt; DataflowId:
        return DataflowId(self.flow_id)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="bytewax.dataflow.Dataflow.flow_id"><code class="language-python name">var <span class="ident">flow_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.Dataflow.substeps"><code class="language-python name">var <span class="ident">substeps</span> : List[<a title="bytewax.dataflow.Operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator">Operator</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bytewax.dataflow.DataflowId"><code class="language-python flex name class">
<span>class <span class="ident">DataflowId</span></span>
<span>(</span><span>flow_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Unique ID of a dataflow.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@dataclass(frozen=True)
class DataflowId:
    &#34;&#34;&#34;Unique ID of a dataflow.&#34;&#34;&#34;

    flow_id: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="bytewax.dataflow.DataflowId.flow_id"><code class="language-python name">var <span class="ident">flow_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bytewax.dataflow.MultiPort"><code class="language-python flex name class">
<span>class <span class="ident">MultiPort</span></span>
<span>(</span><span>port_id: str, stream_ids: Dict[~K, str])</span>
</code></dt>
<dd>
<div class="desc"><p>A multi-stream input or output location on an <code><a title="bytewax.dataflow.Operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator">Operator</a></code>.</p>
<p>You won't be instantiating this manually. The <code><a title="bytewax.dataflow.operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.operator">operator()</a></code> decorator
will create these for you whenever an operator function takes or
returns a <code>*args</code> of <code><a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a></code> or <code>**kwargs</code> of <code><a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a></code>s or a
<code>MultiStream</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@dataclass(frozen=True)
class MultiPort(Generic[K]):
    &#34;&#34;&#34;A multi-stream input or output location on an `Operator`.

    You won&#39;t be instantiating this manually. The `operator` decorator
    will create these for you whenever an operator function takes or
    returns a `*args` of `Stream` or `**kwargs` of `Stream`s or a
    `MultiStream`.

    &#34;&#34;&#34;

    port_id: str
    stream_ids: Dict[K, str]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bytewax.dataflow.MultiPort.port_id"><code class="language-python name">var <span class="ident">port_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.MultiPort.stream_ids"><code class="language-python name">var <span class="ident">stream_ids</span> : Dict[~K, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bytewax.dataflow.Operator"><code class="language-python flex name class">
<span>class <span class="ident">Operator</span></span>
<span>(</span><span>step_name: str, step_id: str, substeps: List[Self])</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for an operator type.</p>
<p>Subclasses of this must be generated via the <code><a title="bytewax.dataflow.operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.operator">operator()</a></code> builder
function decorator. See the <code><a title="bytewax.dataflow" href="/apidocs/bytewax.dataflow">bytewax.dataflow</a></code> module docstring
for a tutorial.</p>
<p>Subclasses will contain the specific configuration fields each
operator needs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@dataclass(frozen=True)
class Operator:
    &#34;&#34;&#34;Base class for an operator type.

    Subclasses of this must be generated via the `operator` builder
    function decorator. See the `bytewax.dataflow` module docstring
    for a tutorial.

    Subclasses will contain the specific configuration fields each
    operator needs.

    &#34;&#34;&#34;

    step_name: str
    step_id: str
    substeps: List[Self]
    ups_names: ClassVar[List[str]]
    dwn_names: ClassVar[List[str]]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>bytewax.connectors.kafka.operators._kafka_error_split</li>
<li>bytewax.connectors.kafka.operators._to_sink</li>
<li><a title="bytewax.connectors.kafka.operators.deserialize" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.deserialize">deserialize()</a></li>
<li><a title="bytewax.connectors.kafka.operators.deserialize_key" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.deserialize_key">deserialize_key()</a></li>
<li><a title="bytewax.connectors.kafka.operators.deserialize_value" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.deserialize_value">deserialize_value()</a></li>
<li><a title="bytewax.connectors.kafka.operators.input" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.input">input()</a></li>
<li><a title="bytewax.connectors.kafka.operators.output" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.output">output()</a></li>
<li><a title="bytewax.connectors.kafka.operators.serialize" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.serialize">serialize()</a></li>
<li><a title="bytewax.connectors.kafka.operators.serialize_key" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.serialize_key">serialize_key()</a></li>
<li><a title="bytewax.connectors.kafka.operators.serialize_value" href="/apidocs/bytewax.connectors/kafka/operators#bytewax.connectors.kafka.operators.serialize_value">serialize_value()</a></li>
<li>bytewax.dataflow._CoreOperator</li>
<li>bytewax.operators._join_name_merge</li>
<li><a title="bytewax.operators.collect" href="/apidocs/bytewax.operators/index#bytewax.operators.collect">collect()</a></li>
<li><a title="bytewax.operators.count_final" href="/apidocs/bytewax.operators/index#bytewax.operators.count_final">count_final()</a></li>
<li><a title="bytewax.operators.filter" href="/apidocs/bytewax.operators/index#bytewax.operators.filter">filter()</a></li>
<li><a title="bytewax.operators.filter_map" href="/apidocs/bytewax.operators/index#bytewax.operators.filter_map">filter_map()</a></li>
<li><a title="bytewax.operators.filter_value" href="/apidocs/bytewax.operators/index#bytewax.operators.filter_value">filter_value()</a></li>
<li><a title="bytewax.operators.flat_map" href="/apidocs/bytewax.operators/index#bytewax.operators.flat_map">flat_map()</a></li>
<li><a title="bytewax.operators.flat_map_value" href="/apidocs/bytewax.operators/index#bytewax.operators.flat_map_value">flat_map_value()</a></li>
<li><a title="bytewax.operators.flatten" href="/apidocs/bytewax.operators/index#bytewax.operators.flatten">flatten()</a></li>
<li><a title="bytewax.operators.fold_final" href="/apidocs/bytewax.operators/index#bytewax.operators.fold_final">fold_final()</a></li>
<li><a title="bytewax.operators.inspect" href="/apidocs/bytewax.operators/index#bytewax.operators.inspect">inspect()</a></li>
<li><a title="bytewax.operators.join" href="/apidocs/bytewax.operators/index#bytewax.operators.join">join()</a></li>
<li><a title="bytewax.operators.join_named" href="/apidocs/bytewax.operators/index#bytewax.operators.join_named">join_named()</a></li>
<li><a title="bytewax.operators.key_on" href="/apidocs/bytewax.operators/index#bytewax.operators.key_on">key_on()</a></li>
<li><a title="bytewax.operators.map" href="/apidocs/bytewax.operators/index#bytewax.operators.map">map()</a></li>
<li><a title="bytewax.operators.map_value" href="/apidocs/bytewax.operators/index#bytewax.operators.map_value">map_value()</a></li>
<li><a title="bytewax.operators.max_final" href="/apidocs/bytewax.operators/index#bytewax.operators.max_final">max_final()</a></li>
<li><a title="bytewax.operators.min_final" href="/apidocs/bytewax.operators/index#bytewax.operators.min_final">min_final()</a></li>
<li><a title="bytewax.operators.raises" href="/apidocs/bytewax.operators/index#bytewax.operators.raises">raises()</a></li>
<li><a title="bytewax.operators.reduce_final" href="/apidocs/bytewax.operators/index#bytewax.operators.reduce_final">reduce_final()</a></li>
<li><a title="bytewax.operators.stateful_map" href="/apidocs/bytewax.operators/index#bytewax.operators.stateful_map">stateful_map()</a></li>
<li><a title="bytewax.operators.window.collect_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.collect_window">collect_window()</a></li>
<li><a title="bytewax.operators.window.count_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.count_window">count_window()</a></li>
<li><a title="bytewax.operators.window.join_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.join_window">join_window()</a></li>
<li><a title="bytewax.operators.window.join_window_named" href="/apidocs/bytewax.operators/window#bytewax.operators.window.join_window_named">join_window_named()</a></li>
<li><a title="bytewax.operators.window.max_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.max_window">max_window()</a></li>
<li><a title="bytewax.operators.window.min_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.min_window">min_window()</a></li>
<li><a title="bytewax.operators.window.reduce_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.reduce_window">reduce_window()</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bytewax.dataflow.Operator.dwn_names"><code class="language-python name">var <span class="ident">dwn_names</span> : ClassVar[List[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.Operator.step_id"><code class="language-python name">var <span class="ident">step_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.Operator.step_name"><code class="language-python name">var <span class="ident">step_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.Operator.substeps"><code class="language-python name">var <span class="ident">substeps</span> : List[Self]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.Operator.ups_names"><code class="language-python name">var <span class="ident">ups_names</span> : ClassVar[List[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bytewax.dataflow.Port"><code class="language-python flex name class">
<span>class <span class="ident">Port</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic interface to a port.</p>
<p>Either <code><a title="bytewax.dataflow.SinglePort" href="/apidocs/bytewax.dataflow#bytewax.dataflow.SinglePort">SinglePort</a></code> or <code><a title="bytewax.dataflow.MultiPort" href="/apidocs/bytewax.dataflow#bytewax.dataflow.MultiPort">MultiPort</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@runtime_checkable
class Port(Protocol):
    &#34;&#34;&#34;Generic interface to a port.

    Either `SinglePort` or `MultiPort`.

    &#34;&#34;&#34;

    port_id: str
    stream_ids: Dict[str, str]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bytewax.dataflow.Port.port_id"><code class="language-python name">var <span class="ident">port_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.Port.stream_ids"><code class="language-python name">var <span class="ident">stream_ids</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="bytewax.dataflow.SinglePort"><code class="language-python flex name class">
<span>class <span class="ident">SinglePort</span></span>
<span>(</span><span>port_id: str, stream_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A input or output location on an <code><a title="bytewax.dataflow.Operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator">Operator</a></code>.</p>
<p>You won't be instantiating this manually. The <code><a title="bytewax.dataflow.operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.operator">operator()</a></code> decorator
will create these for you whenever an operator function takes or
returns a <code><a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@dataclass(frozen=True)
class SinglePort:
    &#34;&#34;&#34;A input or output location on an `Operator`.

    You won&#39;t be instantiating this manually. The `operator` decorator
    will create these for you whenever an operator function takes or
    returns a `Stream`.

    &#34;&#34;&#34;

    port_id: str
    stream_id: str

    @property
    def stream_ids(self) -&gt; Dict[str, str]:
        &#34;&#34;&#34;Allow this to conform to the `Port` protocol.&#34;&#34;&#34;
        return {&#34;stream&#34;: self.stream_id}</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="bytewax.dataflow.SinglePort.port_id"><code class="language-python name">var <span class="ident">port_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="bytewax.dataflow.SinglePort.stream_id"><code class="language-python name">var <span class="ident">stream_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="bytewax.dataflow.SinglePort.stream_ids"><code class="language-python name">var <span class="ident">stream_ids</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"><p>Allow this to conform to the <code><a title="bytewax.dataflow.Port" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Port">Port</a></code> protocol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@property
def stream_ids(self) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Allow this to conform to the `Port` protocol.&#34;&#34;&#34;
    return {&#34;stream&#34;: self.stream_id}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bytewax.dataflow.Stream"><code class="language-python flex name class">
<span>class <span class="ident">Stream</span></span>
<span>(</span><span>stream_id: str, _scope: bytewax.dataflow._Scope)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle to a specific stream of items you can add steps to.</p>
<p>You won't be instantiating this manually. Use the
<code><a title="bytewax.operators" href="/apidocs/bytewax.operators/index">bytewax.operators</a></code> (e.g. <code><a title="bytewax.operators.map" href="/apidocs/bytewax.operators/index#bytewax.operators.map">map()</a></code>,
<code><a title="bytewax.operators.filter" href="/apidocs/bytewax.operators/index#bytewax.operators.filter">filter()</a></code>, <code><a title="bytewax.operators.key_on" href="/apidocs/bytewax.operators/index#bytewax.operators.key_on">key_on()</a></code>) to create
<code><a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a></code>s.</p>
<p>You can reference this stream multiple times to duplicate the data
within.</p>
<p>Operator functions take or return this if they want to create an
input or output port.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@dataclass(frozen=True)
class Stream(Generic[X_co]):
    &#34;&#34;&#34;Handle to a specific stream of items you can add steps to.

    You won&#39;t be instantiating this manually. Use the
    `bytewax.operators` (e.g. `bytewax.operators.map`,
    `bytewax.operators.filter`, `bytewax.operators.key_on`) to create
    `Stream`s.

    You can reference this stream multiple times to duplicate the data
    within.

    Operator functions take or return this if they want to create an
    input or output port.

    &#34;&#34;&#34;

    stream_id: str
    _scope: _Scope = field(compare=False)

    def flow(self) -&gt; Dataflow:
        &#34;&#34;&#34;The containing `Dataflow`.

        You might want access to this to add &#34;top level&#34; operators
        like `bytewax.operators.merge_all.merge_all`.

        &#34;&#34;&#34;
        return self._scope.flow

    def _get_scopes(self) -&gt; Iterable[_Scope]:
        return [self._scope]

    def _with_scope(self, scope: _Scope) -&gt; Self:
        return dataclasses.replace(self, _scope=scope)

    def _to_ref(self, ref_id: str) -&gt; SinglePort:
        return SinglePort(ref_id, self.stream_id)

    def then(
        self,
        op_fn: Callable[Concatenate[str, Self, P], R],
        step_id: str,
        *args: P.args,
        **kwargs: P.kwargs,
    ) -&gt; R:
        &#34;&#34;&#34;Chain a new step onto this stream.

        This allows you to add intermediate steps to a dataflow
        without needing to nest operator function calls or make
        intermediate variables.

        The following two dataflow definitions are equivalent:

        &gt;&gt;&gt; import bytewax.operators as op
        &gt;&gt;&gt; from bytewax.testing import run_main, TestingSource
        &gt;&gt;&gt; from bytewax.dataflow import Dataflow
        &gt;&gt;&gt; def add_one(item):
        ...     return item + 1

        &gt;&gt;&gt; flow = Dataflow(&#34;map_eg&#34;)
        &gt;&gt;&gt; s = op.input(&#34;inp&#34;, flow, TestingSource(range(3)))
        &gt;&gt;&gt; s = op.map(&#34;add_one&#34;, s, add_one)

        and

        &gt;&gt;&gt; flow = Dataflow(&#34;map_eg&#34;)
        &gt;&gt;&gt; s = op.input(&#34;inp&#34;, flow, TestingSource(range(3))).then(
        ...     op.map, &#34;add_one&#34;, add_one
        ... )

        This kind of method chaining is called a &#34;fluent style API&#34;.

        Because this style requires a single upstream before the `.`,
        this transformation only works for operators that could be
        called like `op_fn(step_id, upstream, ...)`, like
        `bytewax.operators.map`. It will not work for operators like
        `bytewax.operators.join_named`, since they do not have that
        shape of function signature.

        Args:
            step_id: Unique ID.

            op_fn: Operator function. This fluent transformation only
              works on operators that take a single stream as the
              second argument.

            *args: Remaining arguments to pass to `op_fn`.

            **kwargs: Remaining arguments to pass to `op_fn`.

        &#34;&#34;&#34;
        return op_fn(step_id, self, *args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="bytewax.dataflow.Stream.stream_id"><code class="language-python name">var <span class="ident">stream_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="bytewax.dataflow.Stream.flow"><code class="language-python name flex">
<span>def <span class="ident">flow</span></span>(<span>self) ‑> <a title="bytewax.dataflow.Dataflow" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Dataflow">Dataflow</a></span>
</code></dt>
<dd>
<div class="desc"><p>The containing <code><a title="bytewax.dataflow.Dataflow" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Dataflow">Dataflow</a></code>.</p>
<p>You might want access to this to add "top level" operators
like <code>bytewax.operators.merge_all.merge_all</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">def flow(self) -&gt; Dataflow:
    &#34;&#34;&#34;The containing `Dataflow`.

    You might want access to this to add &#34;top level&#34; operators
    like `bytewax.operators.merge_all.merge_all`.

    &#34;&#34;&#34;
    return self._scope.flow</code></pre>
</details>
</dd>
<dt id="bytewax.dataflow.Stream.then"><code class="language-python name flex">
<span>def <span class="ident">then</span></span>(<span>self, op_fn: Callable[Concatenate[str, Self, ~P], ~R], step_id: str, *args: P.args, **kwargs: P.kwargs) ‑> ~R</span>
</code></dt>
<dd>
<div class="desc"><p>Chain a new step onto this stream.</p>
<p>This allows you to add intermediate steps to a dataflow
without needing to nest operator function calls or make
intermediate variables.</p>
<p>The following two dataflow definitions are equivalent:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import bytewax.operators as op
&gt;&gt;&gt; from bytewax.testing import run_main, TestingSource
&gt;&gt;&gt; from bytewax.dataflow import Dataflow
&gt;&gt;&gt; def add_one(item):
...     return item + 1
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; flow = Dataflow(&quot;map_eg&quot;)
&gt;&gt;&gt; s = op.input(&quot;inp&quot;, flow, TestingSource(range(3)))
&gt;&gt;&gt; s = op.map(&quot;add_one&quot;, s, add_one)
</code></pre>
<p>and</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; flow = Dataflow(&quot;map_eg&quot;)
&gt;&gt;&gt; s = op.input(&quot;inp&quot;, flow, TestingSource(range(3))).then(
...     op.map, &quot;add_one&quot;, add_one
... )
</code></pre>
<p>This kind of method chaining is called a "fluent style API".</p>
<p>Because this style requires a single upstream before the <code>.</code>,
this transformation only works for operators that could be
called like <code>op_fn(step_id, upstream, &hellip;)</code>, like
<code><a title="bytewax.operators.map" href="/apidocs/bytewax.operators/index#bytewax.operators.map">map()</a></code>. It will not work for operators like
<code><a title="bytewax.operators.join_named" href="/apidocs/bytewax.operators/index#bytewax.operators.join_named">join_named()</a></code>, since they do not have that
shape of function signature.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>op_fn</code></strong></dt>
<dd>Operator function. This fluent transformation only
works on operators that take a single stream as the
second argument.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Remaining arguments to pass to <code>op_fn</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Remaining arguments to pass to <code>op_fn</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">def then(
    self,
    op_fn: Callable[Concatenate[str, Self, P], R],
    step_id: str,
    *args: P.args,
    **kwargs: P.kwargs,
) -&gt; R:
    &#34;&#34;&#34;Chain a new step onto this stream.

    This allows you to add intermediate steps to a dataflow
    without needing to nest operator function calls or make
    intermediate variables.

    The following two dataflow definitions are equivalent:

    &gt;&gt;&gt; import bytewax.operators as op
    &gt;&gt;&gt; from bytewax.testing import run_main, TestingSource
    &gt;&gt;&gt; from bytewax.dataflow import Dataflow
    &gt;&gt;&gt; def add_one(item):
    ...     return item + 1

    &gt;&gt;&gt; flow = Dataflow(&#34;map_eg&#34;)
    &gt;&gt;&gt; s = op.input(&#34;inp&#34;, flow, TestingSource(range(3)))
    &gt;&gt;&gt; s = op.map(&#34;add_one&#34;, s, add_one)

    and

    &gt;&gt;&gt; flow = Dataflow(&#34;map_eg&#34;)
    &gt;&gt;&gt; s = op.input(&#34;inp&#34;, flow, TestingSource(range(3))).then(
    ...     op.map, &#34;add_one&#34;, add_one
    ... )

    This kind of method chaining is called a &#34;fluent style API&#34;.

    Because this style requires a single upstream before the `.`,
    this transformation only works for operators that could be
    called like `op_fn(step_id, upstream, ...)`, like
    `bytewax.operators.map`. It will not work for operators like
    `bytewax.operators.join_named`, since they do not have that
    shape of function signature.

    Args:
        step_id: Unique ID.

        op_fn: Operator function. This fluent transformation only
          works on operators that take a single stream as the
          second argument.

        *args: Remaining arguments to pass to `op_fn`.

        **kwargs: Remaining arguments to pass to `op_fn`.

    &#34;&#34;&#34;
    return op_fn(step_id, self, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
<footer class="api__footer" id="footer">
<p class="api__footer-copyright">
Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.
</p>
</footer>
</article>
<nav class="api__sidebar" id="sidebar">
<ul class="api__sidebar-nav" id="index">
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title">Super-module</h3>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item">
<a title="bytewax" href="/apidocs/">bytewax</a>
</li>
</ul>
</li>
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title"><a href="#header-functions">Functions</a></h3>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.f_repr" href="/apidocs/bytewax.dataflow#bytewax.dataflow.f_repr">f_repr</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.operator">operator</a></li>
</ul>
</li>
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title"><a href="#header-classes">Classes</a></h3>
<ul class="api__sidebar-nav-classes">
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.dataflow.Dataflow" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Dataflow">Dataflow</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Dataflow.flow_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Dataflow.flow_id">flow_id</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Dataflow.substeps" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Dataflow.substeps">substeps</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.dataflow.DataflowId" href="/apidocs/bytewax.dataflow#bytewax.dataflow.DataflowId">DataflowId</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.DataflowId.flow_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.DataflowId.flow_id">flow_id</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.dataflow.MultiPort" href="/apidocs/bytewax.dataflow#bytewax.dataflow.MultiPort">MultiPort</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.MultiPort.port_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.MultiPort.port_id">port_id</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.MultiPort.stream_ids" href="/apidocs/bytewax.dataflow#bytewax.dataflow.MultiPort.stream_ids">stream_ids</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.dataflow.Operator" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator">Operator</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Operator.dwn_names" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator.dwn_names">dwn_names</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Operator.step_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator.step_id">step_id</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Operator.step_name" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator.step_name">step_name</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Operator.substeps" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator.substeps">substeps</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Operator.ups_names" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Operator.ups_names">ups_names</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.dataflow.Port" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Port">Port</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Port.port_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Port.port_id">port_id</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Port.stream_ids" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Port.stream_ids">stream_ids</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.dataflow.SinglePort" href="/apidocs/bytewax.dataflow#bytewax.dataflow.SinglePort">SinglePort</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.SinglePort.port_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.SinglePort.port_id">port_id</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.SinglePort.stream_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.SinglePort.stream_id">stream_id</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.SinglePort.stream_ids" href="/apidocs/bytewax.dataflow#bytewax.dataflow.SinglePort.stream_ids">stream_ids</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Stream.flow" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream.flow">flow</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Stream.stream_id" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream.stream_id">stream_id</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.dataflow.Stream.then" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream.then">then</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
