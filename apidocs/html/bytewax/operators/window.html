<main class="api__content">
<article class="api__article" id="content">
<header class="api__article-header">
<h1 class="api__article-title">Module <strong>bytewax.operators.window</strong></h1>
</header>
<section class="api__article-intro" id="section-intro">
<p>Time-based windowing operators.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">&#34;&#34;&#34;Time-based windowing operators.&#34;&#34;&#34;

from functools import partial
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    Set,
    Tuple,
    Type,
    TypeVar,
    overload,
)

import bytewax.operators as op
from bytewax.dataflow import (
    Stream,
    operator,
)
from bytewax.operators import KeyedStream, _identity, _JoinState, _untyped_none

from ..bytewax import (  # type: ignore[import]
    ClockConfig,
    EventClockConfig,
    SessionWindow,
    SlidingWindow,
    SystemClockConfig,
    TumblingWindow,
    WindowConfig,
    WindowMetadata,
)

__all__ = [
    &#34;ClockConfig&#34;,
    &#34;EventClockConfig&#34;,
    &#34;SessionWindow&#34;,
    &#34;SlidingWindow&#34;,
    &#34;SystemClockConfig&#34;,
    &#34;TumblingWindow&#34;,
    &#34;WindowConfig&#34;,
    &#34;WindowMetadata&#34;,
    &#34;collect_window&#34;,
    &#34;count_window&#34;,
    &#34;fold_window&#34;,
    &#34;join_window&#34;,
    &#34;join_window_named&#34;,
    &#34;max_window&#34;,
    &#34;min_window&#34;,
    &#34;reduce_window&#34;,
]

C = TypeVar(&#34;C&#34;, bound=Iterable)
K = TypeVar(&#34;K&#34;)
X = TypeVar(&#34;X&#34;)  # Item
Y = TypeVar(&#34;Y&#34;)  # Output Item
V = TypeVar(&#34;V&#34;)  # Value
W = TypeVar(&#34;W&#34;)  # Output Value
S = TypeVar(&#34;S&#34;)  # State


def _list_collector(s: List[V], v: V) -&gt; List[V]:
    s.append(v)
    return s


def _set_collector(s: Set[V], v: V) -&gt; Set[V]:
    s.add(v)
    return s


def _dict_collector(s: Dict[K, V], k_v: Tuple[K, V]) -&gt; Dict[K, V]:
    k, v = k_v
    s[k] = v
    return s


def _get_collector(t: Type) -&gt; Callable:
    if issubclass(t, list):
        return _list_collector
    elif issubclass(t, set):
        return _set_collector
    elif issubclass(t, dict):
        return _dict_collector
    else:
        msg = (
            f&#34;collect doesn&#39;t support `{t:!}`; &#34;
            &#34;only `list`, `set`, and `dict`; use `fold` operator directly&#34;
        )
        raise TypeError(msg)


@overload
def collect_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
) -&gt; KeyedStream[List[V]]:
    ...


@overload
def collect_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    into: Type[List],
) -&gt; KeyedStream[List[V]]:
    ...


@overload
def collect_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    into: Type[Set],
) -&gt; KeyedStream[Set[V]]:
    ...


@overload
def collect_window(
    step_id: str,
    up: KeyedStream[Tuple[K, V]],
    clock: ClockConfig,
    windower: WindowConfig,
    into: Type[Dict],
) -&gt; KeyedStream[Dict[K, V]]:
    ...


@operator
def collect_window(
    step_id: str,
    up: KeyedStream,
    clock: ClockConfig,
    windower: WindowConfig,
    into: Type = list,
) -&gt; KeyedStream:
    &#34;&#34;&#34;Collect all items in a window into a container.

    Args:
        step_id: Unique ID.

        up: Stream of items to count.

        clock: Clock.

        windower: Windower.

        into: Type to collect into. Defaults to `list`.

    Returns:
        A keyed stream of the collected containers at the end of each
        window.

    &#34;&#34;&#34;
    collector = _get_collector(into)

    return fold_window(&#34;fold_window&#34;, up, clock, windower, into, collector)


@operator
def count_window(
    step_id: str,
    up: Stream[X],
    clock: ClockConfig,
    windower: WindowConfig,
    key: Callable[[X], str],
) -&gt; KeyedStream[int]:
    &#34;&#34;&#34;Count the number of occurrences of items in a window.

    Args:
        step_id: Unique ID.

        up: Stream of items to count.

        clock: Clock.

        windower: Windower.

        key: Function to convert each item into a string key. The
            counting machinery does not compare the items directly,
            instead it groups by this string key.

    Returns:
        A stream of `(key, count)` per window at the end of each window.

    &#34;&#34;&#34;
    init_count: KeyedStream[int] = op.map(&#34;init_count&#34;, up, lambda x: (key(x), 1))
    return reduce_window(&#34;sum&#34;, init_count, clock, windower, lambda s, x: s + x)


@operator(_core=True)
def fold_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    builder: Callable[[], S],
    folder: Callable[[S, V], S],
) -&gt; KeyedStream[S]:
    &#34;&#34;&#34;Build an empty accumulator, then combine values into it.

    It is like `reduce_window` but uses a function to build the initial
    value.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        builder: Called the first time a key appears and is expected
            to return the empty accumulator for that key.

        folder: Combines a new value into an existing accumulator and
            returns the updated accumulator. The accumulator is
            initially the empty accumulator.

    Returns:
        A keyed stream of the accumulators once each window has
        closed.

    &#34;&#34;&#34;
    return Stream(f&#34;{up._scope.parent_id}.down&#34;, up._scope)


def _join_window_folder(
    state: _JoinState[V], name_value: Tuple[str, V]
) -&gt; _JoinState[V]:
    name, value = name_value
    state.add_val(name, value)
    return state


@operator
def join_window(
    step_id: str,
    clock: ClockConfig,
    windower: WindowConfig,
    *sides: KeyedStream[V],
) -&gt; KeyedStream[Tuple]:
    &#34;&#34;&#34;Gather together the value for a key on multiple streams.

    Args:
        step_id: Unique ID.

        clock: Clock.

        windower: Windower.

        *sides: Keyed streams.

    Returns:
        Emits a tuple with the value from each stream in the order of
        the argument list once each window has closed.

    &#34;&#34;&#34;
    named_sides = dict((str(i), s) for i, s in enumerate(sides))
    names = list(named_sides.keys())

    merged = op._join_name_merge(&#34;add_names&#34;, **named_sides)

    def builder() -&gt; _JoinState[V]:
        return _JoinState.for_names(names)

    joined = fold_window(
        &#34;join&#34;,
        merged,
        clock,
        windower,
        builder,
        _join_window_folder,
    )
    return op.flat_map_value(&#34;astuple&#34;, joined, _JoinState.astuples)


@operator
def join_window_named(
    step_id: str,
    clock: ClockConfig,
    windower: WindowConfig,
    **sides: KeyedStream[V],
) -&gt; KeyedStream[Dict[str, V]]:
    &#34;&#34;&#34;Gather together the value for a key on multiple named streams.

    Args:
        step_id: Unique ID.

        clock: Clock.

        windower: Windower.

        **sides: Named keyed streams. The name of each stream will be
            used in the emitted `dict`s.

    Returns:
        Emits a `dict` mapping the name to the value from each stream
        once each window has closed.

    &#34;&#34;&#34;
    names = list(sides.keys())

    merged = op._join_name_merge(&#34;add_names&#34;, **sides)

    def builder() -&gt; _JoinState[V]:
        return _JoinState.for_names(names)

    joined = fold_window(
        &#34;join&#34;,
        merged,
        clock,
        windower,
        builder,
        _join_window_folder,
    )
    return op.flat_map_value(&#34;asdict&#34;, joined, _JoinState.asdicts)


@overload
def max_window(
    step_id: str, up: KeyedStream[V], clock: ClockConfig, windower: WindowConfig
) -&gt; KeyedStream[V]:
    ...


@overload
def max_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    by: Callable[[V], Any],
) -&gt; KeyedStream[V]:
    ...


@operator
def max_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    by=_identity,
) -&gt; KeyedStream:
    &#34;&#34;&#34;Find the minumum value for each key.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        by: A function called on each value that is used to extract
            what to compare.

    Returns:
        A keyed stream of the min values once each window has closed.

    &#34;&#34;&#34;
    return reduce_window(&#34;reduce_window&#34;, up, clock, windower, partial(max, key=by))


@overload
def min_window(
    step_id: str, up: KeyedStream[V], clock: ClockConfig, windower: WindowConfig
) -&gt; KeyedStream[V]:
    ...


@overload
def min_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    by: Callable[[V], Any],
) -&gt; KeyedStream[V]:
    ...


@operator
def min_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    by=_identity,
) -&gt; KeyedStream:
    &#34;&#34;&#34;Find the minumum value for each key.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        by: A function called on each value that is used to extract
            what to compare.

    Returns:
        A keyed stream of the min values once each window has closed.

    &#34;&#34;&#34;
    return reduce_window(&#34;reduce_window&#34;, up, clock, windower, partial(min, key=by))


@operator
def reduce_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    reducer: Callable[[V, V], V],
) -&gt; KeyedStream[V]:
    &#34;&#34;&#34;Distill all values for a key down into a single value.

    It is like `fold_window` but the first value is the initial
    accumulator.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        reducer: Combines a new value into an old value and returns
            the combined value.

    Returns:
        A keyed stream of the reduced values once each window has
        closed.

    &#34;&#34;&#34;

    def shim_folder(s: V, v: V) -&gt; V:
        if s is None:
            s = v
        else:
            s = reducer(s, v)

        return s

    return fold_window(&#34;fold_window&#34;, up, clock, windower, _untyped_none, shim_folder)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="api__article-subtitle" id="header-functions">Functions</h2>
<dl>
<dt id="bytewax.operators.window.collect_window"><code class="language-python name flex">
<span>def <span class="ident">collect_window</span></span>(<span>step_id: str, up: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]], clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, into: Type = builtins.list) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]]</span>
</code></dt>
<dd>
<div class="desc"><p>Collect all items in a window into a container.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>up</code></strong></dt>
<dd>Stream of items to count.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>into</code></strong></dt>
<dd>Type to collect into. Defaults to <code>list</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A keyed stream of the collected containers at the end of each
window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator
def collect_window(
    step_id: str,
    up: KeyedStream,
    clock: ClockConfig,
    windower: WindowConfig,
    into: Type = list,
) -&gt; KeyedStream:
    &#34;&#34;&#34;Collect all items in a window into a container.

    Args:
        step_id: Unique ID.

        up: Stream of items to count.

        clock: Clock.

        windower: Windower.

        into: Type to collect into. Defaults to `list`.

    Returns:
        A keyed stream of the collected containers at the end of each
        window.

    &#34;&#34;&#34;
    collector = _get_collector(into)

    return fold_window(&#34;fold_window&#34;, up, clock, windower, into, collector)</code></pre>
</details>
</dd>
<dt id="bytewax.operators.window.count_window"><code class="language-python name flex">
<span>def <span class="ident">count_window</span></span>(<span>step_id: str, up: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[~X], clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, key: Callable[[~X], str]) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of occurrences of items in a window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>up</code></strong></dt>
<dd>Stream of items to count.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>key</code></strong></dt>
<dd>Function to convert each item into a string key. The
counting machinery does not compare the items directly,
instead it groups by this string key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A stream of <code>(key, count)</code> per window at the end of each window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator
def count_window(
    step_id: str,
    up: Stream[X],
    clock: ClockConfig,
    windower: WindowConfig,
    key: Callable[[X], str],
) -&gt; KeyedStream[int]:
    &#34;&#34;&#34;Count the number of occurrences of items in a window.

    Args:
        step_id: Unique ID.

        up: Stream of items to count.

        clock: Clock.

        windower: Windower.

        key: Function to convert each item into a string key. The
            counting machinery does not compare the items directly,
            instead it groups by this string key.

    Returns:
        A stream of `(key, count)` per window at the end of each window.

    &#34;&#34;&#34;
    init_count: KeyedStream[int] = op.map(&#34;init_count&#34;, up, lambda x: (key(x), 1))
    return reduce_window(&#34;sum&#34;, init_count, clock, windower, lambda s, x: s + x)</code></pre>
</details>
</dd>
<dt id="bytewax.operators.window.fold_window"><code class="language-python name flex">
<span>def <span class="ident">fold_window</span></span>(<span>step_id: str, up: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]], clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, builder: Callable[[], ~S], folder: Callable[[~S, ~V], ~S]) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~S]]</span>
</code></dt>
<dd>
<div class="desc"><p>Build an empty accumulator, then combine values into it.</p>
<p>It is like <code><a title="bytewax.operators.window.reduce_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.reduce_window">reduce_window()</a></code> but uses a function to build the initial
value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>up</code></strong></dt>
<dd>Keyed stream.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>builder</code></strong></dt>
<dd>Called the first time a key appears and is expected
to return the empty accumulator for that key.</dd>
<dt><strong><code>folder</code></strong></dt>
<dd>Combines a new value into an existing accumulator and
returns the updated accumulator. The accumulator is
initially the empty accumulator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A keyed stream of the accumulators once each window has
closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator(_core=True)
def fold_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    builder: Callable[[], S],
    folder: Callable[[S, V], S],
) -&gt; KeyedStream[S]:
    &#34;&#34;&#34;Build an empty accumulator, then combine values into it.

    It is like `reduce_window` but uses a function to build the initial
    value.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        builder: Called the first time a key appears and is expected
            to return the empty accumulator for that key.

        folder: Combines a new value into an existing accumulator and
            returns the updated accumulator. The accumulator is
            initially the empty accumulator.

    Returns:
        A keyed stream of the accumulators once each window has
        closed.

    &#34;&#34;&#34;
    return Stream(f&#34;{up._scope.parent_id}.down&#34;, up._scope)</code></pre>
</details>
</dd>
<dt id="bytewax.operators.window.join_window"><code class="language-python name flex">
<span>def <span class="ident">join_window</span></span>(<span>step_id: str, clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, *sides: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]]) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, typing.Tuple]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gather together the value for a key on multiple streams.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>*sides</code></strong></dt>
<dd>Keyed streams.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Emits a tuple with the value from each stream in the order of
the argument list once each window has closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator
def join_window(
    step_id: str,
    clock: ClockConfig,
    windower: WindowConfig,
    *sides: KeyedStream[V],
) -&gt; KeyedStream[Tuple]:
    &#34;&#34;&#34;Gather together the value for a key on multiple streams.

    Args:
        step_id: Unique ID.

        clock: Clock.

        windower: Windower.

        *sides: Keyed streams.

    Returns:
        Emits a tuple with the value from each stream in the order of
        the argument list once each window has closed.

    &#34;&#34;&#34;
    named_sides = dict((str(i), s) for i, s in enumerate(sides))
    names = list(named_sides.keys())

    merged = op._join_name_merge(&#34;add_names&#34;, **named_sides)

    def builder() -&gt; _JoinState[V]:
        return _JoinState.for_names(names)

    joined = fold_window(
        &#34;join&#34;,
        merged,
        clock,
        windower,
        builder,
        _join_window_folder,
    )
    return op.flat_map_value(&#34;astuple&#34;, joined, _JoinState.astuples)</code></pre>
</details>
</dd>
<dt id="bytewax.operators.window.join_window_named"><code class="language-python name flex">
<span>def <span class="ident">join_window_named</span></span>(<span>step_id: str, clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, **sides: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]]) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, typing.Dict[str, ~V]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gather together the value for a key on multiple named streams.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>**sides</code></strong></dt>
<dd>Named keyed streams. The name of each stream will be
used in the emitted <code>dict</code>s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Emits a <code>dict</code> mapping the name to the value from each stream
once each window has closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator
def join_window_named(
    step_id: str,
    clock: ClockConfig,
    windower: WindowConfig,
    **sides: KeyedStream[V],
) -&gt; KeyedStream[Dict[str, V]]:
    &#34;&#34;&#34;Gather together the value for a key on multiple named streams.

    Args:
        step_id: Unique ID.

        clock: Clock.

        windower: Windower.

        **sides: Named keyed streams. The name of each stream will be
            used in the emitted `dict`s.

    Returns:
        Emits a `dict` mapping the name to the value from each stream
        once each window has closed.

    &#34;&#34;&#34;
    names = list(sides.keys())

    merged = op._join_name_merge(&#34;add_names&#34;, **sides)

    def builder() -&gt; _JoinState[V]:
        return _JoinState.for_names(names)

    joined = fold_window(
        &#34;join&#34;,
        merged,
        clock,
        windower,
        builder,
        _join_window_folder,
    )
    return op.flat_map_value(&#34;asdict&#34;, joined, _JoinState.asdicts)</code></pre>
</details>
</dd>
<dt id="bytewax.operators.window.max_window"><code class="language-python name flex">
<span>def <span class="ident">max_window</span></span>(<span>step_id: str, up: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]], clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, by=&lt;function _identity&gt;) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the minumum value for each key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>up</code></strong></dt>
<dd>Keyed stream.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>by</code></strong></dt>
<dd>A function called on each value that is used to extract
what to compare.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A keyed stream of the min values once each window has closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator
def max_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    by=_identity,
) -&gt; KeyedStream:
    &#34;&#34;&#34;Find the minumum value for each key.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        by: A function called on each value that is used to extract
            what to compare.

    Returns:
        A keyed stream of the min values once each window has closed.

    &#34;&#34;&#34;
    return reduce_window(&#34;reduce_window&#34;, up, clock, windower, partial(max, key=by))</code></pre>
</details>
</dd>
<dt id="bytewax.operators.window.min_window"><code class="language-python name flex">
<span>def <span class="ident">min_window</span></span>(<span>step_id: str, up: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]], clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, by=&lt;function _identity&gt;) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the minumum value for each key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>up</code></strong></dt>
<dd>Keyed stream.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>by</code></strong></dt>
<dd>A function called on each value that is used to extract
what to compare.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A keyed stream of the min values once each window has closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator
def min_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    by=_identity,
) -&gt; KeyedStream:
    &#34;&#34;&#34;Find the minumum value for each key.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        by: A function called on each value that is used to extract
            what to compare.

    Returns:
        A keyed stream of the min values once each window has closed.

    &#34;&#34;&#34;
    return reduce_window(&#34;reduce_window&#34;, up, clock, windower, partial(min, key=by))</code></pre>
</details>
</dd>
<dt id="bytewax.operators.window.reduce_window"><code class="language-python name flex">
<span>def <span class="ident">reduce_window</span></span>(<span>step_id: str, up: <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]], clock: bytewax.window.ClockConfig, windower: bytewax.window.WindowConfig, reducer: Callable[[~V, ~V], ~V]) ‑> <a title="bytewax.dataflow.Stream" href="/apidocs/bytewax.dataflow#bytewax.dataflow.Stream">Stream</a>[typing.Tuple[str, ~V]]</span>
</code></dt>
<dd>
<div class="desc"><p>Distill all values for a key down into a single value.</p>
<p>It is like <code><a title="bytewax.operators.window.fold_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.fold_window">fold_window()</a></code> but the first value is the initial
accumulator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>step_id</code></strong></dt>
<dd>Unique ID.</dd>
<dt><strong><code>up</code></strong></dt>
<dd>Keyed stream.</dd>
<dt><strong><code>clock</code></strong></dt>
<dd>Clock.</dd>
<dt><strong><code>windower</code></strong></dt>
<dd>Windower.</dd>
<dt><strong><code>reducer</code></strong></dt>
<dd>Combines a new value into an old value and returns
the combined value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A keyed stream of the reduced values once each window has
closed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre class="language-python line-numbers"><code class="language-python">@operator
def reduce_window(
    step_id: str,
    up: KeyedStream[V],
    clock: ClockConfig,
    windower: WindowConfig,
    reducer: Callable[[V, V], V],
) -&gt; KeyedStream[V]:
    &#34;&#34;&#34;Distill all values for a key down into a single value.

    It is like `fold_window` but the first value is the initial
    accumulator.

    Args:
        step_id: Unique ID.

        up: Keyed stream.

        clock: Clock.

        windower: Windower.

        reducer: Combines a new value into an old value and returns
            the combined value.

    Returns:
        A keyed stream of the reduced values once each window has
        closed.

    &#34;&#34;&#34;

    def shim_folder(s: V, v: V) -&gt; V:
        if s is None:
            s = v
        else:
            s = reducer(s, v)

        return s

    return fold_window(&#34;fold_window&#34;, up, clock, windower, _untyped_none, shim_folder)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="api__article-subtitle" id="header-classes">Classes</h2>
<dl>
<dt id="bytewax.operators.window.ClockConfig"><code class="language-python flex name class">
<span>class <span class="ident">ClockConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for a clock config.</p>
<p>This describes how a windowing operator should determine the
current time and the time for each element.</p>
<p>Use a specific subclass of this that matches the time definition
you'd like to use.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>bytewax.window.EventClockConfig</li>
<li>bytewax.window.SystemClockConfig</li>
</ul>
</dd>
<dt id="bytewax.operators.window.EventClockConfig"><code class="language-python flex name class">
<span>class <span class="ident">EventClockConfig</span></span>
<span>(</span><span>dt_getter, wait_for_system_duration)</span>
</code></dt>
<dd>
<div class="desc"><p>Use a getter function to lookup the timestamp for each item.</p>
<p>The watermark is the largest item timestamp seen thus far, minus
the waiting duration, plus the system time duration that has
elapsed since that item was seen. This effectively means items
will be correctly processed as long as they are not out of order
more than the waiting duration in system time.</p>
<p>If the dataflow has no more input, all windows are closed.</p>
<h2 id="args">Args</h2>
<p>dt_getter:
Python function to get a datetime from an event. The datetime
returned must have tzinfo set to
<code>timezone.utc</code>. E.g. <code>datetime(1970, 1, 1,
tzinfo=timezone.utc)</code>
wait_for_system_duration:
How much system time to wait before considering an event late.</p>
<h2 id="returns">Returns</h2>
<p>Config object. Pass this as the <code>clock_config</code> parameter to
your windowing operator.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bytewax.window.ClockConfig</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="bytewax.operators.window.EventClockConfig.dt_getter"><code class="language-python name">var <span class="ident">dt_getter</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="bytewax.operators.window.EventClockConfig.wait_for_system_duration"><code class="language-python name">var <span class="ident">wait_for_system_duration</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="bytewax.operators.window.SessionWindow"><code class="language-python flex name class">
<span>class <span class="ident">SessionWindow</span></span>
<span>(</span><span>gap)</span>
</code></dt>
<dd>
<div class="desc"><p>Session windowing with a fixed inactivity gap.
Each time a new item is received, it is added to the latest
window if the time since the latest event is &lt; gap.
Otherwise a new window is created that starts at current clock's time.</p>
<p>Args:
gap (datetime.timedelta):
Gap of inactivity before considering a session closed. The
gap should not be negative.</p>
<h2 id="returns">Returns</h2>
<p>Config object. Pass this as the <code>window_config</code> parameter to
your windowing operator.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bytewax.window.WindowConfig</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="bytewax.operators.window.SessionWindow.gap"><code class="language-python name">var <span class="ident">gap</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="bytewax.operators.window.SlidingWindow"><code class="language-python flex name class">
<span>class <span class="ident">SlidingWindow</span></span>
<span>(</span><span>length, offset, align_to)</span>
</code></dt>
<dd>
<div class="desc"><p>Sliding windows of fixed duration.</p>
<p>If offset == length, windows cover all time but do not
overlap. Each item will fall in exactly one window. The
<code><a title="bytewax.operators.window.TumblingWindow" href="/apidocs/bytewax.operators/window#bytewax.operators.window.TumblingWindow">TumblingWindow</a></code> config will do this for you.</p>
<p>If offset &lt; length, windows overlap. Each item will fall in
multiple windows.</p>
<p>If offset &gt; length, there will be gaps between windows. Each item
can fall in up to one window, but might fall into none.</p>
<p>Window start times are inclusive, but end times are exclusive.</p>
<h2 id="args">Args</h2>
<p>length (datetime.timedelta):
Length of windows.
offset (datetime.timedelta):
Duration between start times of adjacent windows.
align_to (datetime.datetime):
Align windows so this instant starts a window. This must be a
constant. You can use this to align all windows to hour
boundaries, e.g.</p>
<h2 id="returns">Returns</h2>
<p>Config object. Pass this as the <code>window_config</code> parameter to
your windowing operator.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bytewax.window.WindowConfig</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="bytewax.operators.window.SlidingWindow.align_to"><code class="language-python name">var <span class="ident">align_to</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="bytewax.operators.window.SlidingWindow.length"><code class="language-python name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="bytewax.operators.window.SlidingWindow.offset"><code class="language-python name">var <span class="ident">offset</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="bytewax.operators.window.SystemClockConfig"><code class="language-python flex name class">
<span>class <span class="ident">SystemClockConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Use the current system time as the timestamp for each item.</p>
<p>The watermark is also the current system time.</p>
<p>If the dataflow has no more input, all windows are closed.</p>
<h2 id="returns">Returns</h2>
<p>Config object. Pass this as the <code>clock_config</code> parameter to
your windowing operator.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bytewax.window.ClockConfig</li>
</ul>
</dd>
<dt id="bytewax.operators.window.TumblingWindow"><code class="language-python flex name class">
<span>class <span class="ident">TumblingWindow</span></span>
<span>(</span><span>length, align_to)</span>
</code></dt>
<dd>
<div class="desc"><p>Tumbling windows of fixed duration.</p>
<p>Each item will fall in exactly one window.</p>
<p>Window start times are inclusive, but end times are exclusive.</p>
<h2 id="args">Args</h2>
<p>length (datetime.timedelta):
Length of windows.
align_to (datetime.datetime):
Align windows so this instant starts a window. This must be a
constant. You can use this to align all windows to hour
boundaries, e.g.</p>
<h2 id="returns">Returns</h2>
<p>Config object. Pass this as the <code>window_config</code> parameter to
your windowing operator.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bytewax.window.WindowConfig</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="bytewax.operators.window.TumblingWindow.align_to"><code class="language-python name">var <span class="ident">align_to</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="bytewax.operators.window.TumblingWindow.length"><code class="language-python name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
<dt id="bytewax.operators.window.WindowConfig"><code class="language-python flex name class">
<span>class <span class="ident">WindowConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for a windower config.</p>
<p>This describes the type of windows you would like.</p>
<p>Use a specific subclass of this that matches the window definition
you'd like to use.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li>bytewax.window.SessionWindow</li>
<li>bytewax.window.SlidingWindow</li>
<li>bytewax.window.TumblingWindow</li>
</ul>
</dd>
<dt id="bytewax.operators.window.WindowMetadata"><code class="language-python flex name class">
<span>class <span class="ident">WindowMetadata</span></span>
<span>(</span><span>open_time, close_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Metadata object for a window.</p>
<p>Args:
key (WindowKey):
Internal window ID
open_time (datetime.datetime)
The time that the window starts.
close_time (datetime.datetime)
The time that the window closes. For some window
types(SessionWindow), this value can change as new
data is received.</p>
<h2 id="returns">Returns</h2>
<p>WindowMetadata object</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="bytewax.operators.window.WindowMetadata.close_time"><code class="language-python name">var <span class="ident">close_time</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="bytewax.operators.window.WindowMetadata.open_time"><code class="language-python name">var <span class="ident">open_time</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
<footer class="api__footer" id="footer">
<p class="api__footer-copyright">
Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.
</p>
</footer>
</article>
<nav class="api__sidebar" id="sidebar">
<ul class="api__sidebar-nav" id="index">
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title">Super-module</h3>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item">
<a title="bytewax.operators" href="/apidocs/bytewax.operators/index">bytewax.operators</a>
</li>
</ul>
</li>
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title"><a href="#header-functions">Functions</a></h3>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.collect_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.collect_window">collect_window</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.count_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.count_window">count_window</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.fold_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.fold_window">fold_window</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.join_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.join_window">join_window</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.join_window_named" href="/apidocs/bytewax.operators/window#bytewax.operators.window.join_window_named">join_window_named</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.max_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.max_window">max_window</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.min_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.min_window">min_window</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.reduce_window" href="/apidocs/bytewax.operators/window#bytewax.operators.window.reduce_window">reduce_window</a></li>
</ul>
</li>
<li class="api__sidebar-nav-item">
<h3 class="api__sidebar-nav-title"><a href="#header-classes">Classes</a></h3>
<ul class="api__sidebar-nav-classes">
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.ClockConfig" href="/apidocs/bytewax.operators/window#bytewax.operators.window.ClockConfig">ClockConfig</a></h4>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.EventClockConfig" href="/apidocs/bytewax.operators/window#bytewax.operators.window.EventClockConfig">EventClockConfig</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.EventClockConfig.dt_getter" href="/apidocs/bytewax.operators/window#bytewax.operators.window.EventClockConfig.dt_getter">dt_getter</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.EventClockConfig.wait_for_system_duration" href="/apidocs/bytewax.operators/window#bytewax.operators.window.EventClockConfig.wait_for_system_duration">wait_for_system_duration</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.SessionWindow" href="/apidocs/bytewax.operators/window#bytewax.operators.window.SessionWindow">SessionWindow</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.SessionWindow.gap" href="/apidocs/bytewax.operators/window#bytewax.operators.window.SessionWindow.gap">gap</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.SlidingWindow" href="/apidocs/bytewax.operators/window#bytewax.operators.window.SlidingWindow">SlidingWindow</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.SlidingWindow.align_to" href="/apidocs/bytewax.operators/window#bytewax.operators.window.SlidingWindow.align_to">align_to</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.SlidingWindow.length" href="/apidocs/bytewax.operators/window#bytewax.operators.window.SlidingWindow.length">length</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.SlidingWindow.offset" href="/apidocs/bytewax.operators/window#bytewax.operators.window.SlidingWindow.offset">offset</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.SystemClockConfig" href="/apidocs/bytewax.operators/window#bytewax.operators.window.SystemClockConfig">SystemClockConfig</a></h4>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.TumblingWindow" href="/apidocs/bytewax.operators/window#bytewax.operators.window.TumblingWindow">TumblingWindow</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.TumblingWindow.align_to" href="/apidocs/bytewax.operators/window#bytewax.operators.window.TumblingWindow.align_to">align_to</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.TumblingWindow.length" href="/apidocs/bytewax.operators/window#bytewax.operators.window.TumblingWindow.length">length</a></li>
</ul>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.WindowConfig" href="/apidocs/bytewax.operators/window#bytewax.operators.window.WindowConfig">WindowConfig</a></h4>
</li>
<li class="api__sidebar-nav-classes-item">
<h4 class="api__sidebar-nav-classes-title"><a title="bytewax.operators.window.WindowMetadata" href="/apidocs/bytewax.operators/window#bytewax.operators.window.WindowMetadata">WindowMetadata</a></h4>
<ul class="api__sidebar-nav-menu">
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.WindowMetadata.close_time" href="/apidocs/bytewax.operators/window#bytewax.operators.window.WindowMetadata.close_time">close_time</a></li>
<li class="api__sidebar-nav-menu-item"><a title="bytewax.operators.window.WindowMetadata.open_time" href="/apidocs/bytewax.operators/window#bytewax.operators.window.WindowMetadata.open_time">open_time</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
