# An overview of the Bytewax Architecture

## Bytewax from 10,000 feet

### Timely Roots

Bytewax has its roots in the Rust project [Timely Dataflow]() and although it is not necessary to understand Timely Dataflow to use Bytewax, it is a core component (the distributed processing engine) of Bytewax and many of the concepts are passed through. The short history of Timely Dataflow is that there were a few folks ([Frank McSherry] and [Derek G. Murray]) working for Microsoft Research about a decade ago that worked on a project called [Naiad](https://www.youtube.com/watch?v=yyhMI9r0A9E). Naiad was a system designed around the concept of how you could create a distributed system to execute dataflow programs that would be performant across batch, stream, and graph processing. From the [paper abstract](https://dl.acm.org/doi/10.1145/2517349.2522738): 
> Naiad is a distributed system for executing data parallel, cyclic dataflow programs. It offers the high throughput of batch processors, the low latency of stream processors, and the ability to perform iterative and incremental computations. Although existing systems offer some of these features, applications that require all three have relied on multiple platforms, at the expense of efficiency, maintainability, and simplicity. Naiad resolves the complexities of combining these features in one framework.
> A new computational model, timely dataflow, underlies Naiad and captures opportunities for parallelism across a wide class of algorithms. This model enriches dataflow computation with timestamps that represent logical points in the computation and provide the basis for an efficient, lightweight coordination mechanism.
> We show that many powerful high-level programming models can be built on Naiad's low-level primitives, enabling such diverse tasks as streaming data analysis, iterative machine learning, and interactive graph mining. Naiad outperforms specialized systems in their target application domains, and its unique features enable the development of new high-performance applications.

At some point, Microsoft Research changed direction with respect to the Silicon Valley Lab (I don't know the real story, but some of the prior reporting on it is [here](https://www.vox.com/2014/9/18/11631044/microsoft-shuts-down-silicon-valley-research-lab-amid-broader-layoffs)) and in some way or another, the team moved on from there to start other things. Many of the original team kept the idea of dataflow programs core to what they next worked on. Frank went on to spend time working on a Rust version of the core tenants of Naiad and Derek went on to bring the core dataflow programming concepts to tensorflow.

## of Pythons and Crabs

Bytewax leverages another open-source project to bring the Python Native capabilities on top of a Rust processing engine. This project is called PyO3 and is used by some of our friends at [PyDantic], [Polars], [ReRun] and more. PyO3 is a great project that allows you to run Rust functions from Python like a foreign function interface, and it also lets you embed Python in Rust. Many more libraries are starting to leverage this combination of Rust and Python as it provides a very powerful combination of easy to use and broad applicability of Python with the performance and security benefits of Rust. In Bytewax we both call Rust from Python, but also embed Python in Rust. This can get a little tricky and is the less commonly used pattern used in PyO3.

## Putting it all together

![bytewax_arch(2)](https://github.com/bytewax/developer-relations/assets/6073079/1e5a25f9-3f76-414f-a652-c5f54876f06d)
> https://excalidraw.com/#json=TdvLIlABLMyGeHdAqL-Ih,r13ADBKyxNq7uVShJgg58g

This is a rough diagram of the Bytewax architecture. The developer interacts with the Bytewax API by writing Python code. The describe the dataflow program via connectors and operators and provide the Python native code that will execute any transformations. The operators exposed in the bytewax API via PyO3 like `dataflow.map` are based on the Timely Operators by the same name in many cases, although some have been modified or extended for ease of use. When a dataflow is run with the `bytewax.run` command the dataflow program is run on each Timely worker and the developer's Python code will run in the Python interpreter running on the Timely worker. State and progress from the dataflow is persisted from memory to SQLite for recovery purposes and this can also be backed up in the cloud (S3, Azure Blob etc.) when using the Bytewax platform.

## Bytewax at sea level

A user interfaces with the Bytewax API to construct a dataflow program in Python that loosely resembles the image below. A dataflow will at the very least run on one Timely worker, have one input and output connector and most likely, but not strictly necessary, have one operator with some transformation code.

![dataflow_diagram](https://github.com/bytewax/developer-relations/assets/6073079/073c14e8-f942-4138-8477-28a76be7f0fa)
> https://excalidraw.com/#json=qiQd1RU8tUoA72E5nj76r,uhPLyY6F7i5hIaqDRMi7yg

There is a lot of coordination going on behind the scenes of what seems quite simple when you run `python -m bytewax.run dataflow:flow -p 3`. When that command is issued, Bytewax will construct the dataflow and via timely and run 3 dataflow workers on separate processes. These all communicate via Timely communication mechanisms and are essentially independent aside from stateful operations when data is exchanged to ensure the right data lands on the right worker.

Once the workers have started and established communication, then the dataflow program will begin executing. The operators in Timely are eager and will consume data as fast as possible. The input operators are designed to be stateful and partitioned. This means that input data, if partitioned can be equally partitioned across the dataflow workers as well. Each worker input connector should be designed to track progress in a way that syncs with the state so that in the instance in which a worker crashes the recovered state will match the progress. For example, if you were to read lines in a file and then split the line into words and do some work on each word individually, like say update the word count you wouldn't want to end up with duplicate words in the instance of a crash and restart. In this example, the line number could be the progress and if we were to restart, we would want our program to restart loading the state (the word counts) that matches the beginning of the line and not halfway through the words in the line.

The connectors, progress tracking, recovery mechanisms, and scaling the number of workers are all highly interconnected work between Bytewax code, storage infrastructure and Timely mechanisms.

Below is a diagram of the internal mechanisms behind a production dataflow with recovery, progress tracking, rescaling potential and stateful operators. It becomes quite complex when you put all the pieces together.

[![bytewax](https://mermaid.ink/img/pako:eNqlVW1v2jAQ_iuWP6wgQUbS8iq10gICIRVlWiYtbNkHkxiISOzIsdsyK_99jsM7rIL1W3x3z91zzzlnCQMaYtiDC4bSJfg-8EkmZuXBh99wJhIM-igOwABxNI_pqw998jyW8iujC4azDIxJKnieg3odzBklPMIMiDREHCvTE3j-MZHySxCIRMTKVga-UrZSYbt4HWhLaTOKwgBl_J2w_oV8QSwyfhbpStlfIkJwnOcFaVA3QMroDANDu32CSegT5XLB4yNgZbc4pcFSnZ_AGHwC7rgIONBE9R2KgEeUHEniKklcXjS90-Ow2KhfhBRUfVhRVFMQhTWwwutaWa_aA5lGz9YcZz7UDbhDT8phFKvOyjZvwTreQMoJSnfIOw19u7sE3YP-i-b0AzSnF2mu36c59cm4ooWuFrCI4yTTLs8zK78Mw_hd3aTTSV5QLHB132RFT2ouYuCkmCFOGfCqxbCd6QXXtKpEcbzS_8-0nmcdVN4zcsyKI7hiCsyihGNtj5ZK65jadIKYbBQpy94yPff6kZ-Mobifu-6um8EHi_XV30lJgPg1l2YLtbd_mY2ClSg1sm-8c_ZeX2ei9LcnRYIlRozPMOLlEAbDE34H_s8XF9PQPliKW3pXIQfD89V3BAo3i-YYpneKrXfUjQqM-jeJf4KVcoTYDC3Uw0DjGAfqHym0HJ9vPLVeYQ0mmCUoCtUjI30CVC2-xImaaE99hoitivWZqzgkOHXXJIA9zgSuwfIRGURIrd5ka0wR-Unp4RH2JHyDPdNsGVbbvO9aHcuyWs2WVYNrZTa6je59wzLN5sND477Vaec1-EdnaBidTsdsm61mt9tpmFbDyv8CUTQ8UQ?type=png)](https://mermaid.live/edit#pako:eNqlVW1v2jAQ_iuWP6wgQUbS8iq10gICIRVlWiYtbNkHkxiISOzIsdsyK_99jsM7rIL1W3x3z91zzzlnCQMaYtiDC4bSJfg-8EkmZuXBh99wJhIM-igOwABxNI_pqw998jyW8iujC4azDIxJKnieg3odzBklPMIMiDREHCvTE3j-MZHySxCIRMTKVga-UrZSYbt4HWhLaTOKwgBl_J2w_oV8QSwyfhbpStlfIkJwnOcFaVA3QMroDANDu32CSegT5XLB4yNgZbc4pcFSnZ_AGHwC7rgIONBE9R2KgEeUHEniKklcXjS90-Ow2KhfhBRUfVhRVFMQhTWwwutaWa_aA5lGz9YcZz7UDbhDT8phFKvOyjZvwTreQMoJSnfIOw19u7sE3YP-i-b0AzSnF2mu36c59cm4ooWuFrCI4yTTLs8zK78Mw_hd3aTTSV5QLHB132RFT2ouYuCkmCFOGfCqxbCd6QXXtKpEcbzS_8-0nmcdVN4zcsyKI7hiCsyihGNtj5ZK65jadIKYbBQpy94yPff6kZ-Mobifu-6um8EHi_XV30lJgPg1l2YLtbd_mY2ClSg1sm-8c_ZeX2ei9LcnRYIlRozPMOLlEAbDE34H_s8XF9PQPliKW3pXIQfD89V3BAo3i-YYpneKrXfUjQqM-jeJf4KVcoTYDC3Uw0DjGAfqHym0HJ9vPLVeYQ0mmCUoCtUjI30CVC2-xImaaE99hoitivWZqzgkOHXXJIA9zgSuwfIRGURIrd5ka0wR-Unp4RH2JHyDPdNsGVbbvO9aHcuyWs2WVYNrZTa6je59wzLN5sND477Vaec1-EdnaBidTsdsm61mt9tpmFbDyv8CUTQ8UQ)
